"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/booking",{

/***/ "./utils/supabase.ts":
/*!***************************!*\
  !*** ./utils/supabase.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkVillaAvailability: function() { return /* binding */ checkVillaAvailability; },\n/* harmony export */   createBooking: function() { return /* binding */ createBooking; },\n/* harmony export */   getSupabaseClient: function() { return /* binding */ getSupabaseClient; },\n/* harmony export */   getVillaById: function() { return /* binding */ getVillaById; },\n/* harmony export */   loadMockData: function() { return /* binding */ loadMockData; },\n/* harmony export */   testSupabaseConnection: function() { return /* binding */ testSupabaseConnection; }\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"./node_modules/@supabase/supabase-js/dist/module/index.js\");\n\n// Mock data for fallback when Supabase isn't available\nlet mockVillas = [];\nlet mockBookings = [];\n// Try to initialize Supabase client with environment variables\nlet supabaseUrl;\nlet supabaseKey;\nlet supabaseClient = null;\n// Handle the case when running in the browser where window is defined\nif (true) {\n    supabaseUrl = \"https://strvmujzcfzqaqoksnlh.supabase.co\";\n    supabaseKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InN0cnZtdWp6Y2Z6cWFxb2tzbmxoIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDE4NTY3NDEsImV4cCI6MjA1NzQzMjc0MX0.JNKAXzQAHbk9uxrBITPoII_qk2TD5aLSwMtnk5fGzao\";\n    console.log(\"Supabase config:\", {\n        urlDefined: !!supabaseUrl,\n        keyDefined: !!supabaseKey,\n        urlValue: supabaseUrl ? supabaseUrl.substring(0, 8) + \"...\" : \"undefined\",\n        keyValue: supabaseKey ? supabaseKey.substring(0, 5) + \"...\" : \"undefined\"\n    });\n    // Load mock data if needed\n    try {\n        // In Next.js, you can't directly use fs in the browser,\n        // so we'll load mock data from an API endpoint if needed\n        if (!supabaseUrl || !supabaseKey) {\n            console.warn(\"Missing Supabase credentials, will use mock data\");\n        } else {\n            // Initialize Supabase client if credentials are available\n            supabaseClient = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseKey);\n            console.log(\"Supabase client initialized successfully\");\n        }\n    } catch (error) {\n        console.error(\"Error initializing Supabase:\", error);\n    }\n}\n// Initialize Supabase client if we have valid credentials\nif (supabaseUrl && supabaseKey) {\n    supabaseClient = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseKey);\n}\n// Utility function to get the Supabase client\nconst getSupabaseClient = ()=>{\n    if (!supabaseClient) {\n        // Return mock client if actual client isn't available\n        return {\n            from: (table)=>{\n                return {\n                    select: (columns)=>{\n                        return {\n                            data: table === \"villas\" ? mockVillas : mockBookings,\n                            error: null,\n                            // Mock supabase query methods\n                            eq: (column, value)=>{\n                                let filtered = [];\n                                if (table === \"villas\") {\n                                    filtered = mockVillas.filter((item)=>item[column] === value);\n                                } else if (table === \"bookings\") {\n                                    filtered = mockBookings.filter((item)=>item[column] === value);\n                                }\n                                return {\n                                    data: filtered,\n                                    error: null,\n                                    single: ()=>{\n                                        return {\n                                            data: filtered.length > 0 ? filtered[0] : null,\n                                            error: filtered.length > 0 ? null : {\n                                                message: \"Not found\"\n                                            }\n                                        };\n                                    }\n                                };\n                            }\n                        };\n                    },\n                    insert: (data)=>{\n                        const newItem = {\n                            id: \"mock-\".concat(Date.now()),\n                            created_at: new Date().toISOString(),\n                            ...data\n                        };\n                        if (table === \"villas\") {\n                            mockVillas.push(newItem);\n                        } else if (table === \"bookings\") {\n                            mockBookings.push(newItem);\n                        }\n                        return {\n                            data: newItem,\n                            error: null\n                        };\n                    },\n                    update: (data)=>{\n                        return {\n                            match: (param)=>{\n                                let { id } = param;\n                                if (table === \"villas\") {\n                                    const index = mockVillas.findIndex((item)=>item.id === id);\n                                    if (index !== -1) {\n                                        mockVillas[index] = {\n                                            ...mockVillas[index],\n                                            ...data\n                                        };\n                                        return {\n                                            data: mockVillas[index],\n                                            error: null\n                                        };\n                                    }\n                                } else if (table === \"bookings\") {\n                                    const index = mockBookings.findIndex((item)=>item.id === id);\n                                    if (index !== -1) {\n                                        mockBookings[index] = {\n                                            ...mockBookings[index],\n                                            ...data\n                                        };\n                                        return {\n                                            data: mockBookings[index],\n                                            error: null\n                                        };\n                                    }\n                                }\n                                return {\n                                    data: null,\n                                    error: {\n                                        message: \"Item not found\"\n                                    }\n                                };\n                            }\n                        };\n                    },\n                    delete: ()=>{\n                        return {\n                            match: (param)=>{\n                                let { id } = param;\n                                if (table === \"villas\") {\n                                    const index = mockVillas.findIndex((item)=>item.id === id);\n                                    if (index !== -1) {\n                                        const deleted = mockVillas[index];\n                                        mockVillas.splice(index, 1);\n                                        return {\n                                            data: deleted,\n                                            error: null\n                                        };\n                                    }\n                                } else if (table === \"bookings\") {\n                                    const index = mockBookings.findIndex((item)=>item.id === id);\n                                    if (index !== -1) {\n                                        const deleted = mockBookings[index];\n                                        mockBookings.splice(index, 1);\n                                        return {\n                                            data: deleted,\n                                            error: null\n                                        };\n                                    }\n                                }\n                                return {\n                                    data: null,\n                                    error: {\n                                        message: \"Item not found\"\n                                    }\n                                };\n                            }\n                        };\n                    }\n                };\n            }\n        };\n    }\n    return supabaseClient;\n};\nconst supabase = getSupabaseClient();\n/* harmony default export */ __webpack_exports__[\"default\"] = (supabase);\n// Helper function to fetch a villa by ID\nasync function getVillaById(id) {\n    try {\n        if (supabaseClient) {\n            // Use type assertion to satisfy TypeScript\n            const query = supabase.from(\"villas\").select(\"*\");\n            const { data, error } = await query.eq(\"id\", id).single();\n            if (error) {\n                console.error(\"Error fetching villa:\", error);\n                return null;\n            }\n            return data;\n        } else {\n            // For mock implementation\n            const villa = mockVillas.find((v)=>v.id === id);\n            return villa || null;\n        }\n    } catch (error) {\n        console.error(\"Error fetching villa:\", error);\n        return null;\n    }\n}\n// Helper function to create a new booking\nasync function createBooking(bookingData) {\n    try {\n        console.log(\"Submitting booking data to Supabase:\", bookingData);\n        if (supabaseClient) {\n            console.log(\"Using real Supabase client for booking creation\");\n            // Use type assertion to satisfy TypeScript\n            const query = supabase.from(\"bookings\").insert([\n                {\n                    ...bookingData,\n                    created_at: new Date().toISOString()\n                }\n            ]);\n            console.log(\"Prepared insert query for bookings table\");\n            try {\n                const { data, error } = await query.select();\n                if (error) {\n                    console.error(\"Supabase error details:\", {\n                        code: error.code,\n                        message: error.message,\n                        details: error.details,\n                        hint: error.hint\n                    });\n                    throw error;\n                }\n                console.log(\"Booking created successfully:\", data);\n                return data[0];\n            } catch (queryError) {\n                console.error(\"Supabase query execution error:\", queryError);\n                throw queryError;\n            }\n        } else {\n            // For mock implementation, create a fake ID and return the booking\n            console.log(\"Using mock implementation for booking creation\");\n            const newBooking = {\n                ...bookingData,\n                id: \"mock-\".concat(Date.now()),\n                created_at: new Date().toISOString()\n            };\n            mockBookings.push(newBooking);\n            console.log(\"Mock booking created:\", newBooking);\n            return newBooking;\n        }\n    } catch (error) {\n        console.error(\"Error creating booking:\", error);\n        throw error;\n    }\n}\n// Helper function to check villa availability\nasync function checkVillaAvailability(villaId, checkIn, checkOut) {\n    try {\n        // For Supabase client\n        if (supabaseClient) {\n            // Use type assertion to satisfy TypeScript\n            const query = supabase.from(\"bookings\").select(\"*\");\n            const { data, error } = await query.eq(\"villa_id\", villaId).eq(\"status\", \"confirmed\");\n            if (error) {\n                console.error(\"Error checking availability:\", error);\n                return false;\n            }\n            // If there are no bookings for this villa, it's available\n            if (!data || data.length === 0) {\n                return true;\n            }\n            // Check if there are any overlapping bookings\n            const bookings = data;\n            const hasOverlap = bookings.some((booking)=>{\n                const bookingStart = new Date(booking.check_in).getTime();\n                const bookingEnd = new Date(booking.check_out).getTime();\n                const requestStart = new Date(checkIn).getTime();\n                const requestEnd = new Date(checkOut).getTime();\n                return requestStart <= bookingEnd && requestEnd >= bookingStart;\n            });\n            // If there are no overlapping bookings, the villa is available\n            return !hasOverlap;\n        } else {\n            // Filter bookings manually for the mock implementation\n            const confirmedBookings = mockBookings.filter((booking)=>booking.villa_id === villaId && booking.status === \"confirmed\");\n            if (confirmedBookings.length === 0) {\n                return true;\n            }\n            // Check for overlapping bookings\n            const hasOverlap = confirmedBookings.some((booking)=>{\n                const bookingStart = new Date(booking.check_in).getTime();\n                const bookingEnd = new Date(booking.check_out).getTime();\n                const requestStart = new Date(checkIn).getTime();\n                const requestEnd = new Date(checkOut).getTime();\n                return requestStart <= bookingEnd && requestEnd >= bookingStart;\n            });\n            return !hasOverlap;\n        }\n    } catch (error) {\n        console.error(\"Error checking availability:\", error);\n        return false;\n    }\n}\n// Attempt to load mock data from public URL\nconst loadMockData = async ()=>{\n    try {\n        // In a real app, you would fetch this from an API endpoint\n        // For now, we'll just use some hardcoded data\n        mockVillas = [\n            {\n                id: \"550e8400-e29b-41d4-a716-446655440000\",\n                name: \"Luxury Beachfront Villa\",\n                description: \"Experience the ultimate luxury getaway at our stunning beachfront villa. Nestled on the pristine shores of a private beach, this exquisite property offers breathtaking ocean views from every angle.\",\n                short_description: \"Stunning beachfront villa with private pool, direct beach access, and breathtaking ocean views.\",\n                location: \"Malibu, California\",\n                price: 1200.00,\n                bedrooms: 5,\n                bathrooms: 6,\n                max_guests: 12,\n                images: [\n                    \"/images/villa-exterior.jpg\",\n                    \"/images/villa-interior-1.jpg\",\n                    \"/images/villa-interior-2.jpg\",\n                    \"/images/villa-bedroom.jpg\",\n                    \"/images/villa-bathroom.jpg\",\n                    \"/images/villa-pool.jpg\",\n                    \"/images/villa-beach.jpg\",\n                    \"/images/villa-dining.jpg\"\n                ],\n                amenities: [\n                    \"Private Pool\",\n                    \"Direct Beach Access\",\n                    \"Ocean View\",\n                    \"Fully Equipped Kitchen\",\n                    \"Air Conditioning\",\n                    \"Free WiFi\",\n                    \"Smart TV\",\n                    \"Outdoor Dining Area\",\n                    \"BBQ Grill\",\n                    \"Parking\",\n                    \"Gym\",\n                    \"Home Theater\",\n                    \"Laundry Facilities\",\n                    \"24/7 Security\",\n                    \"Concierge Service\"\n                ],\n                created_at: new Date().toISOString()\n            }\n        ];\n        mockBookings = [];\n        console.log(\"Mock data loaded successfully\");\n    } catch (error) {\n        console.error(\"Error loading mock data:\", error);\n    }\n};\n// Load mock data on initialization\nif ( true && (!supabaseUrl || !supabaseKey)) {\n    loadMockData();\n}\n// Helper function to test Supabase connection\nasync function testSupabaseConnection() {\n    try {\n        console.log(\"Testing Supabase connection...\");\n        if (supabaseClient) {\n            // Use actual Supabase client\n            const { data, error } = await supabaseClient.from(\"villas\").select(\"id, name\").limit(1);\n            if (error) {\n                console.error(\"Supabase connection test failed:\", error);\n                return {\n                    success: false,\n                    error: error.message\n                };\n            }\n            console.log(\"Supabase connection successful:\", data);\n            return {\n                success: true,\n                data\n            };\n        } else {\n            // Using mock implementation\n            console.warn(\"Supabase client not initialized, using mock data\");\n            return {\n                success: false,\n                error: \"Supabase client not initialized\"\n            };\n        }\n    } catch (error) {\n        console.error(\"Error testing Supabase connection:\", error);\n        return {\n            success: false,\n            error: String(error)\n        };\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi91dGlscy9zdXBhYmFzZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXFEO0FBbUNyRCx1REFBdUQ7QUFDdkQsSUFBSUMsYUFBc0IsRUFBRTtBQUM1QixJQUFJQyxlQUEwQixFQUFFO0FBRWhDLCtEQUErRDtBQUMvRCxJQUFJQztBQUNKLElBQUlDO0FBQ0osSUFBSUMsaUJBQXlEO0FBRTdELHNFQUFzRTtBQUN0RSxJQUFJLElBQWtCLEVBQWE7SUFDakNGLGNBQWNHLDBDQUFvQztJQUNsREYsY0FBY0Usa05BQXlDO0lBRXZESSxRQUFRQyxHQUFHLENBQUMsb0JBQW9CO1FBQzlCQyxZQUFZLENBQUMsQ0FBQ1Q7UUFDZFUsWUFBWSxDQUFDLENBQUNUO1FBQ2RVLFVBQVVYLGNBQWNBLFlBQVlZLFNBQVMsQ0FBQyxHQUFHLEtBQUssUUFBUTtRQUM5REMsVUFBVVosY0FBY0EsWUFBWVcsU0FBUyxDQUFDLEdBQUcsS0FBSyxRQUFRO0lBQ2hFO0lBRUEsMkJBQTJCO0lBQzNCLElBQUk7UUFDRix3REFBd0Q7UUFDeEQseURBQXlEO1FBQ3pELElBQUksQ0FBQ1osZUFBZSxDQUFDQyxhQUFhO1lBQ2hDTSxRQUFRTyxJQUFJLENBQUM7UUFDZixPQUFPO1lBQ0wsMERBQTBEO1lBQzFEWixpQkFBaUJMLG1FQUFZQSxDQUFDRyxhQUFhQztZQUMzQ00sUUFBUUMsR0FBRyxDQUFDO1FBQ2Q7SUFDRixFQUFFLE9BQU9PLE9BQU87UUFDZFIsUUFBUVEsS0FBSyxDQUFDLGdDQUFnQ0E7SUFDaEQ7QUFDRjtBQUVBLDBEQUEwRDtBQUMxRCxJQUFJZixlQUFlQyxhQUFhO0lBQzlCQyxpQkFBaUJMLG1FQUFZQSxDQUFDRyxhQUFhQztBQUM3QztBQUVBLDhDQUE4QztBQUN2QyxNQUFNZSxvQkFBb0I7SUFDL0IsSUFBSSxDQUFDZCxnQkFBZ0I7UUFDbkIsc0RBQXNEO1FBQ3RELE9BQU87WUFDTGUsTUFBTSxDQUFDQztnQkFDTCxPQUFPO29CQUNMQyxRQUFRLENBQUNDO3dCQUNQLE9BQU87NEJBQ0xDLE1BQU1ILFVBQVUsV0FBV3BCLGFBQWFDOzRCQUN4Q2dCLE9BQU87NEJBRVAsOEJBQThCOzRCQUM5Qk8sSUFBSSxDQUFDQyxRQUFnQkM7Z0NBQ25CLElBQUlDLFdBQWdDLEVBQUU7Z0NBQ3RDLElBQUlQLFVBQVUsVUFBVTtvQ0FDdEJPLFdBQVczQixXQUFXNEIsTUFBTSxDQUFDLENBQUNDLE9BQWdCQSxJQUFJLENBQUNKLE9BQXNCLEtBQUtDO2dDQUNoRixPQUFPLElBQUlOLFVBQVUsWUFBWTtvQ0FDL0JPLFdBQVcxQixhQUFhMkIsTUFBTSxDQUFDLENBQUNDLE9BQWtCQSxJQUFJLENBQUNKLE9BQXdCLEtBQUtDO2dDQUN0RjtnQ0FFQSxPQUFPO29DQUNMSCxNQUFNSTtvQ0FDTlYsT0FBTztvQ0FDUGEsUUFBUTt3Q0FDTixPQUFPOzRDQUNMUCxNQUFNSSxTQUFTSSxNQUFNLEdBQUcsSUFBSUosUUFBUSxDQUFDLEVBQUUsR0FBRzs0Q0FDMUNWLE9BQU9VLFNBQVNJLE1BQU0sR0FBRyxJQUFJLE9BQU87Z0RBQUVDLFNBQVM7NENBQVk7d0NBQzdEO29DQUNGO2dDQUNGOzRCQUNGO3dCQUNGO29CQUNGO29CQUNBQyxRQUFRLENBQUNWO3dCQUNQLE1BQU1XLFVBQVU7NEJBQ2RDLElBQUksUUFBbUIsT0FBWEMsS0FBS0MsR0FBRzs0QkFDcEJDLFlBQVksSUFBSUYsT0FBT0csV0FBVzs0QkFDbEMsR0FBR2hCLElBQUk7d0JBQ1Q7d0JBRUEsSUFBSUgsVUFBVSxVQUFVOzRCQUN0QnBCLFdBQVd3QyxJQUFJLENBQUNOO3dCQUNsQixPQUFPLElBQUlkLFVBQVUsWUFBWTs0QkFDL0JuQixhQUFhdUMsSUFBSSxDQUFDTjt3QkFDcEI7d0JBRUEsT0FBTzs0QkFDTFgsTUFBTVc7NEJBQ05qQixPQUFPO3dCQUNUO29CQUNGO29CQUNBd0IsUUFBUSxDQUFDbEI7d0JBQ1AsT0FBTzs0QkFDTG1CLE9BQU87b0NBQUMsRUFBRVAsRUFBRSxFQUFrQjtnQ0FDNUIsSUFBSWYsVUFBVSxVQUFVO29DQUN0QixNQUFNdUIsUUFBUTNDLFdBQVc0QyxTQUFTLENBQUMsQ0FBQ2YsT0FBY0EsS0FBS00sRUFBRSxLQUFLQTtvQ0FDOUQsSUFBSVEsVUFBVSxDQUFDLEdBQUc7d0NBQ2hCM0MsVUFBVSxDQUFDMkMsTUFBTSxHQUFHOzRDQUFFLEdBQUczQyxVQUFVLENBQUMyQyxNQUFNOzRDQUFFLEdBQUdwQixJQUFJO3dDQUFDO3dDQUNwRCxPQUFPOzRDQUFFQSxNQUFNdkIsVUFBVSxDQUFDMkMsTUFBTTs0Q0FBRTFCLE9BQU87d0NBQUs7b0NBQ2hEO2dDQUNGLE9BQU8sSUFBSUcsVUFBVSxZQUFZO29DQUMvQixNQUFNdUIsUUFBUTFDLGFBQWEyQyxTQUFTLENBQUMsQ0FBQ2YsT0FBY0EsS0FBS00sRUFBRSxLQUFLQTtvQ0FDaEUsSUFBSVEsVUFBVSxDQUFDLEdBQUc7d0NBQ2hCMUMsWUFBWSxDQUFDMEMsTUFBTSxHQUFHOzRDQUFFLEdBQUcxQyxZQUFZLENBQUMwQyxNQUFNOzRDQUFFLEdBQUdwQixJQUFJO3dDQUFDO3dDQUN4RCxPQUFPOzRDQUFFQSxNQUFNdEIsWUFBWSxDQUFDMEMsTUFBTTs0Q0FBRTFCLE9BQU87d0NBQUs7b0NBQ2xEO2dDQUNGO2dDQUVBLE9BQU87b0NBQUVNLE1BQU07b0NBQU1OLE9BQU87d0NBQUVlLFNBQVM7b0NBQWlCO2dDQUFFOzRCQUM1RDt3QkFDRjtvQkFDRjtvQkFDQWEsUUFBUTt3QkFDTixPQUFPOzRCQUNMSCxPQUFPO29DQUFDLEVBQUVQLEVBQUUsRUFBa0I7Z0NBQzVCLElBQUlmLFVBQVUsVUFBVTtvQ0FDdEIsTUFBTXVCLFFBQVEzQyxXQUFXNEMsU0FBUyxDQUFDLENBQUNmLE9BQWNBLEtBQUtNLEVBQUUsS0FBS0E7b0NBQzlELElBQUlRLFVBQVUsQ0FBQyxHQUFHO3dDQUNoQixNQUFNRyxVQUFVOUMsVUFBVSxDQUFDMkMsTUFBTTt3Q0FDakMzQyxXQUFXK0MsTUFBTSxDQUFDSixPQUFPO3dDQUN6QixPQUFPOzRDQUFFcEIsTUFBTXVCOzRDQUFTN0IsT0FBTzt3Q0FBSztvQ0FDdEM7Z0NBQ0YsT0FBTyxJQUFJRyxVQUFVLFlBQVk7b0NBQy9CLE1BQU11QixRQUFRMUMsYUFBYTJDLFNBQVMsQ0FBQyxDQUFDZixPQUFjQSxLQUFLTSxFQUFFLEtBQUtBO29DQUNoRSxJQUFJUSxVQUFVLENBQUMsR0FBRzt3Q0FDaEIsTUFBTUcsVUFBVTdDLFlBQVksQ0FBQzBDLE1BQU07d0NBQ25DMUMsYUFBYThDLE1BQU0sQ0FBQ0osT0FBTzt3Q0FDM0IsT0FBTzs0Q0FBRXBCLE1BQU11Qjs0Q0FBUzdCLE9BQU87d0NBQUs7b0NBQ3RDO2dDQUNGO2dDQUVBLE9BQU87b0NBQUVNLE1BQU07b0NBQU1OLE9BQU87d0NBQUVlLFNBQVM7b0NBQWlCO2dDQUFFOzRCQUM1RDt3QkFDRjtvQkFDRjtnQkFDRjtZQUNGO1FBQ0Y7SUFDRjtJQUNBLE9BQU81QjtBQUNULEVBQUU7QUFFRixNQUFNNEMsV0FBVzlCO0FBQ2pCLCtEQUFlOEIsUUFBUUEsRUFBQztBQUV4Qix5Q0FBeUM7QUFDbEMsZUFBZUMsYUFBYWQsRUFBVTtJQUMzQyxJQUFJO1FBQ0YsSUFBSS9CLGdCQUFnQjtZQUNsQiwyQ0FBMkM7WUFDM0MsTUFBTThDLFFBQVFGLFNBQ1g3QixJQUFJLENBQUMsVUFDTEUsTUFBTSxDQUFDO1lBRVYsTUFBTSxFQUFFRSxJQUFJLEVBQUVOLEtBQUssRUFBRSxHQUFHLE1BQU1pQyxNQUMzQjFCLEVBQUUsQ0FBQyxNQUFNVyxJQUNUTCxNQUFNO1lBRVQsSUFBSWIsT0FBTztnQkFDVFIsUUFBUVEsS0FBSyxDQUFDLHlCQUF5QkE7Z0JBQ3ZDLE9BQU87WUFDVDtZQUVBLE9BQU9NO1FBQ1QsT0FBTztZQUNMLDBCQUEwQjtZQUMxQixNQUFNNEIsUUFBUW5ELFdBQVdvRCxJQUFJLENBQUNDLENBQUFBLElBQUtBLEVBQUVsQixFQUFFLEtBQUtBO1lBQzVDLE9BQU9nQixTQUFTO1FBQ2xCO0lBQ0YsRUFBRSxPQUFPbEMsT0FBTztRQUNkUixRQUFRUSxLQUFLLENBQUMseUJBQXlCQTtRQUN2QyxPQUFPO0lBQ1Q7QUFDRjtBQUVBLDBDQUEwQztBQUNuQyxlQUFlcUMsY0FBY0MsV0FBK0M7SUFDakYsSUFBSTtRQUNGOUMsUUFBUUMsR0FBRyxDQUFDLHdDQUF3QzZDO1FBRXBELElBQUluRCxnQkFBZ0I7WUFDbEJLLFFBQVFDLEdBQUcsQ0FBQztZQUVaLDJDQUEyQztZQUMzQyxNQUFNd0MsUUFBUUYsU0FDWDdCLElBQUksQ0FBQyxZQUNMYyxNQUFNLENBQUM7Z0JBQ047b0JBQ0UsR0FBR3NCLFdBQVc7b0JBQ2RqQixZQUFZLElBQUlGLE9BQU9HLFdBQVc7Z0JBQ3BDO2FBQ0Q7WUFFSDlCLFFBQVFDLEdBQUcsQ0FBQztZQUVaLElBQUk7Z0JBQ0YsTUFBTSxFQUFFYSxJQUFJLEVBQUVOLEtBQUssRUFBRSxHQUFHLE1BQU1pQyxNQUFNN0IsTUFBTTtnQkFFMUMsSUFBSUosT0FBTztvQkFDVFIsUUFBUVEsS0FBSyxDQUFDLDJCQUEyQjt3QkFDdkN1QyxNQUFNdkMsTUFBTXVDLElBQUk7d0JBQ2hCeEIsU0FBU2YsTUFBTWUsT0FBTzt3QkFDdEJ5QixTQUFTeEMsTUFBTXdDLE9BQU87d0JBQ3RCQyxNQUFNekMsTUFBTXlDLElBQUk7b0JBQ2xCO29CQUNBLE1BQU16QztnQkFDUjtnQkFFQVIsUUFBUUMsR0FBRyxDQUFDLGlDQUFpQ2E7Z0JBQzdDLE9BQU9BLElBQUksQ0FBQyxFQUFFO1lBQ2hCLEVBQUUsT0FBT29DLFlBQVk7Z0JBQ25CbEQsUUFBUVEsS0FBSyxDQUFDLG1DQUFtQzBDO2dCQUNqRCxNQUFNQTtZQUNSO1FBQ0YsT0FBTztZQUNMLG1FQUFtRTtZQUNuRWxELFFBQVFDLEdBQUcsQ0FBQztZQUNaLE1BQU1rRCxhQUFhO2dCQUNqQixHQUFHTCxXQUFXO2dCQUNkcEIsSUFBSSxRQUFtQixPQUFYQyxLQUFLQyxHQUFHO2dCQUNwQkMsWUFBWSxJQUFJRixPQUFPRyxXQUFXO1lBQ3BDO1lBRUF0QyxhQUFhdUMsSUFBSSxDQUFDb0I7WUFDbEJuRCxRQUFRQyxHQUFHLENBQUMseUJBQXlCa0Q7WUFDckMsT0FBT0E7UUFDVDtJQUNGLEVBQUUsT0FBTzNDLE9BQU87UUFDZFIsUUFBUVEsS0FBSyxDQUFDLDJCQUEyQkE7UUFDekMsTUFBTUE7SUFDUjtBQUNGO0FBRUEsOENBQThDO0FBQ3ZDLGVBQWU0Qyx1QkFDcEJDLE9BQWUsRUFDZkMsT0FBZSxFQUNmQyxRQUFnQjtJQUVoQixJQUFJO1FBQ0Ysc0JBQXNCO1FBQ3RCLElBQUk1RCxnQkFBZ0I7WUFDbEIsMkNBQTJDO1lBQzNDLE1BQU04QyxRQUFRRixTQUNYN0IsSUFBSSxDQUFDLFlBQ0xFLE1BQU0sQ0FBQztZQUVWLE1BQU0sRUFBRUUsSUFBSSxFQUFFTixLQUFLLEVBQUUsR0FBRyxNQUFNaUMsTUFDM0IxQixFQUFFLENBQUMsWUFBWXNDLFNBQ2Z0QyxFQUFFLENBQUMsVUFBVTtZQUVoQixJQUFJUCxPQUFPO2dCQUNUUixRQUFRUSxLQUFLLENBQUMsZ0NBQWdDQTtnQkFDOUMsT0FBTztZQUNUO1lBRUEsMERBQTBEO1lBQzFELElBQUksQ0FBQ00sUUFBUUEsS0FBS1EsTUFBTSxLQUFLLEdBQUc7Z0JBQzlCLE9BQU87WUFDVDtZQUVBLDhDQUE4QztZQUM5QyxNQUFNa0MsV0FBVzFDO1lBQ2pCLE1BQU0yQyxhQUFhRCxTQUFTRSxJQUFJLENBQUNDLENBQUFBO2dCQUMvQixNQUFNQyxlQUFlLElBQUlqQyxLQUFLZ0MsUUFBUUUsUUFBUSxFQUFFQyxPQUFPO2dCQUN2RCxNQUFNQyxhQUFhLElBQUlwQyxLQUFLZ0MsUUFBUUssU0FBUyxFQUFFRixPQUFPO2dCQUN0RCxNQUFNRyxlQUFlLElBQUl0QyxLQUFLMkIsU0FBU1EsT0FBTztnQkFDOUMsTUFBTUksYUFBYSxJQUFJdkMsS0FBSzRCLFVBQVVPLE9BQU87Z0JBRTdDLE9BQVFHLGdCQUFnQkYsY0FBY0csY0FBY047WUFDdEQ7WUFFQSwrREFBK0Q7WUFDL0QsT0FBTyxDQUFDSDtRQUNWLE9BRUs7WUFDSCx1REFBdUQ7WUFDdkQsTUFBTVUsb0JBQW9CM0UsYUFBYTJCLE1BQU0sQ0FDM0N3QyxDQUFBQSxVQUFXQSxRQUFRUyxRQUFRLEtBQUtmLFdBQVdNLFFBQVFVLE1BQU0sS0FBSztZQUdoRSxJQUFJRixrQkFBa0I3QyxNQUFNLEtBQUssR0FBRztnQkFDbEMsT0FBTztZQUNUO1lBRUEsaUNBQWlDO1lBQ2pDLE1BQU1tQyxhQUFhVSxrQkFBa0JULElBQUksQ0FBQ0MsQ0FBQUE7Z0JBQ3hDLE1BQU1DLGVBQWUsSUFBSWpDLEtBQUtnQyxRQUFRRSxRQUFRLEVBQUVDLE9BQU87Z0JBQ3ZELE1BQU1DLGFBQWEsSUFBSXBDLEtBQUtnQyxRQUFRSyxTQUFTLEVBQUVGLE9BQU87Z0JBQ3RELE1BQU1HLGVBQWUsSUFBSXRDLEtBQUsyQixTQUFTUSxPQUFPO2dCQUM5QyxNQUFNSSxhQUFhLElBQUl2QyxLQUFLNEIsVUFBVU8sT0FBTztnQkFFN0MsT0FBUUcsZ0JBQWdCRixjQUFjRyxjQUFjTjtZQUN0RDtZQUVBLE9BQU8sQ0FBQ0g7UUFDVjtJQUNGLEVBQUUsT0FBT2pELE9BQU87UUFDZFIsUUFBUVEsS0FBSyxDQUFDLGdDQUFnQ0E7UUFDOUMsT0FBTztJQUNUO0FBQ0Y7QUFFQSw0Q0FBNEM7QUFDckMsTUFBTThELGVBQWU7SUFDMUIsSUFBSTtRQUNGLDJEQUEyRDtRQUMzRCw4Q0FBOEM7UUFDOUMvRSxhQUFhO1lBQ1g7Z0JBQ0VtQyxJQUFJO2dCQUNKNkMsTUFBTTtnQkFDTkMsYUFBYTtnQkFDYkMsbUJBQW1CO2dCQUNuQkMsVUFBVTtnQkFDVkMsT0FBTztnQkFDUEMsVUFBVTtnQkFDVkMsV0FBVztnQkFDWEMsWUFBWTtnQkFDWkMsUUFBUTtvQkFDTjtvQkFDQTtvQkFDQTtvQkFDQTtvQkFDQTtvQkFDQTtvQkFDQTtvQkFDQTtpQkFDRDtnQkFDREMsV0FBVztvQkFDVDtvQkFDQTtvQkFDQTtvQkFDQTtvQkFDQTtvQkFDQTtvQkFDQTtvQkFDQTtvQkFDQTtvQkFDQTtvQkFDQTtvQkFDQTtvQkFDQTtvQkFDQTtvQkFDQTtpQkFDRDtnQkFDRG5ELFlBQVksSUFBSUYsT0FBT0csV0FBVztZQUNwQztTQUNEO1FBRUR0QyxlQUFlLEVBQUU7UUFFakJRLFFBQVFDLEdBQUcsQ0FBQztJQUNkLEVBQUUsT0FBT08sT0FBTztRQUNkUixRQUFRUSxLQUFLLENBQUMsNEJBQTRCQTtJQUM1QztBQUNGLEVBQUU7QUFFRixtQ0FBbUM7QUFDbkMsSUFBSSxLQUFrQixJQUFnQixFQUFDZixlQUFlLENBQUNDLFdBQVUsR0FBSTtJQUNuRTRFO0FBQ0Y7QUFFQSw4Q0FBOEM7QUFDdkMsZUFBZVc7SUFDcEIsSUFBSTtRQUNGakYsUUFBUUMsR0FBRyxDQUFDO1FBRVosSUFBSU4sZ0JBQWdCO1lBQ2xCLDZCQUE2QjtZQUM3QixNQUFNLEVBQUVtQixJQUFJLEVBQUVOLEtBQUssRUFBRSxHQUFHLE1BQU1iLGVBQzNCZSxJQUFJLENBQUMsVUFDTEUsTUFBTSxDQUFDLFlBQ1BzRSxLQUFLLENBQUM7WUFFVCxJQUFJMUUsT0FBTztnQkFDVFIsUUFBUVEsS0FBSyxDQUFDLG9DQUFvQ0E7Z0JBQ2xELE9BQU87b0JBQUUyRSxTQUFTO29CQUFPM0UsT0FBT0EsTUFBTWUsT0FBTztnQkFBQztZQUNoRDtZQUVBdkIsUUFBUUMsR0FBRyxDQUFDLG1DQUFtQ2E7WUFDL0MsT0FBTztnQkFBRXFFLFNBQVM7Z0JBQU1yRTtZQUFLO1FBQy9CLE9BQU87WUFDTCw0QkFBNEI7WUFDNUJkLFFBQVFPLElBQUksQ0FBQztZQUNiLE9BQU87Z0JBQUU0RSxTQUFTO2dCQUFPM0UsT0FBTztZQUFrQztRQUNwRTtJQUNGLEVBQUUsT0FBT0EsT0FBTztRQUNkUixRQUFRUSxLQUFLLENBQUMsc0NBQXNDQTtRQUNwRCxPQUFPO1lBQUUyRSxTQUFTO1lBQU8zRSxPQUFPNEUsT0FBTzVFO1FBQU87SUFDaEQ7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi91dGlscy9zdXBhYmFzZS50cz83ZGUzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUNsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcyc7XHJcblxyXG4vLyBEZWZpbmUgdmlsbGEgYW5kIGJvb2tpbmcgdHlwZXNcclxuZXhwb3J0IHR5cGUgVmlsbGEgPSB7XHJcbiAgaWQ6IHN0cmluZztcclxuICBuYW1lOiBzdHJpbmc7XHJcbiAgZGVzY3JpcHRpb246IHN0cmluZztcclxuICBzaG9ydF9kZXNjcmlwdGlvbjogc3RyaW5nO1xyXG4gIGxvY2F0aW9uOiBzdHJpbmc7XHJcbiAgcHJpY2U6IG51bWJlcjtcclxuICBiZWRyb29tczogbnVtYmVyO1xyXG4gIGJhdGhyb29tczogbnVtYmVyO1xyXG4gIG1heF9ndWVzdHM6IG51bWJlcjtcclxuICBpbWFnZXM6IHN0cmluZ1tdO1xyXG4gIGFtZW5pdGllczogc3RyaW5nW107XHJcbiAgY3JlYXRlZF9hdDogc3RyaW5nO1xyXG59O1xyXG5cclxuZXhwb3J0IHR5cGUgQm9va2luZyA9IHtcclxuICBpZDogc3RyaW5nO1xyXG4gIGNoZWNrX2luOiBzdHJpbmc7XHJcbiAgY2hlY2tfb3V0OiBzdHJpbmc7XHJcbiAgZ3Vlc3RzOiBudW1iZXI7XHJcbiAgZmlyc3RfbmFtZTogc3RyaW5nO1xyXG4gIGxhc3RfbmFtZTogc3RyaW5nO1xyXG4gIGVtYWlsOiBzdHJpbmc7XHJcbiAgcGhvbmU6IHN0cmluZztcclxuICBzcGVjaWFsX3JlcXVlc3RzPzogc3RyaW5nO1xyXG4gIHRvdGFsX2Ftb3VudDogbnVtYmVyO1xyXG4gIHBheW1lbnRfaWQ6IHN0cmluZztcclxuICB2aWxsYV9pZDogc3RyaW5nO1xyXG4gIHN0YXR1czogJ3BlbmRpbmcnIHwgJ2NvbmZpcm1lZCcgfCAnY2FuY2VsbGVkJztcclxuICBjcmVhdGVkX2F0OiBzdHJpbmc7XHJcbn07XHJcblxyXG4vLyBNb2NrIGRhdGEgZm9yIGZhbGxiYWNrIHdoZW4gU3VwYWJhc2UgaXNuJ3QgYXZhaWxhYmxlXHJcbmxldCBtb2NrVmlsbGFzOiBWaWxsYVtdID0gW107XHJcbmxldCBtb2NrQm9va2luZ3M6IEJvb2tpbmdbXSA9IFtdO1xyXG5cclxuLy8gVHJ5IHRvIGluaXRpYWxpemUgU3VwYWJhc2UgY2xpZW50IHdpdGggZW52aXJvbm1lbnQgdmFyaWFibGVzXHJcbmxldCBzdXBhYmFzZVVybDogc3RyaW5nIHwgdW5kZWZpbmVkO1xyXG5sZXQgc3VwYWJhc2VLZXk6IHN0cmluZyB8IHVuZGVmaW5lZDtcclxubGV0IHN1cGFiYXNlQ2xpZW50OiBSZXR1cm5UeXBlPHR5cGVvZiBjcmVhdGVDbGllbnQ+IHwgbnVsbCA9IG51bGw7XHJcblxyXG4vLyBIYW5kbGUgdGhlIGNhc2Ugd2hlbiBydW5uaW5nIGluIHRoZSBicm93c2VyIHdoZXJlIHdpbmRvdyBpcyBkZWZpbmVkXHJcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gIHN1cGFiYXNlVXJsID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMO1xyXG4gIHN1cGFiYXNlS2V5ID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVk7XHJcbiAgXHJcbiAgY29uc29sZS5sb2coJ1N1cGFiYXNlIGNvbmZpZzonLCB7IFxyXG4gICAgdXJsRGVmaW5lZDogISFzdXBhYmFzZVVybCwgXHJcbiAgICBrZXlEZWZpbmVkOiAhIXN1cGFiYXNlS2V5LFxyXG4gICAgdXJsVmFsdWU6IHN1cGFiYXNlVXJsID8gc3VwYWJhc2VVcmwuc3Vic3RyaW5nKDAsIDgpICsgJy4uLicgOiAndW5kZWZpbmVkJyxcclxuICAgIGtleVZhbHVlOiBzdXBhYmFzZUtleSA/IHN1cGFiYXNlS2V5LnN1YnN0cmluZygwLCA1KSArICcuLi4nIDogJ3VuZGVmaW5lZCdcclxuICB9KTtcclxuICBcclxuICAvLyBMb2FkIG1vY2sgZGF0YSBpZiBuZWVkZWRcclxuICB0cnkge1xyXG4gICAgLy8gSW4gTmV4dC5qcywgeW91IGNhbid0IGRpcmVjdGx5IHVzZSBmcyBpbiB0aGUgYnJvd3NlcixcclxuICAgIC8vIHNvIHdlJ2xsIGxvYWQgbW9jayBkYXRhIGZyb20gYW4gQVBJIGVuZHBvaW50IGlmIG5lZWRlZFxyXG4gICAgaWYgKCFzdXBhYmFzZVVybCB8fCAhc3VwYWJhc2VLZXkpIHtcclxuICAgICAgY29uc29sZS53YXJuKCdNaXNzaW5nIFN1cGFiYXNlIGNyZWRlbnRpYWxzLCB3aWxsIHVzZSBtb2NrIGRhdGEnKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIEluaXRpYWxpemUgU3VwYWJhc2UgY2xpZW50IGlmIGNyZWRlbnRpYWxzIGFyZSBhdmFpbGFibGVcclxuICAgICAgc3VwYWJhc2VDbGllbnQgPSBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlS2V5KTtcclxuICAgICAgY29uc29sZS5sb2coJ1N1cGFiYXNlIGNsaWVudCBpbml0aWFsaXplZCBzdWNjZXNzZnVsbHknKTtcclxuICAgIH1cclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW5pdGlhbGl6aW5nIFN1cGFiYXNlOicsIGVycm9yKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIEluaXRpYWxpemUgU3VwYWJhc2UgY2xpZW50IGlmIHdlIGhhdmUgdmFsaWQgY3JlZGVudGlhbHNcclxuaWYgKHN1cGFiYXNlVXJsICYmIHN1cGFiYXNlS2V5KSB7XHJcbiAgc3VwYWJhc2VDbGllbnQgPSBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlS2V5KTtcclxufVxyXG5cclxuLy8gVXRpbGl0eSBmdW5jdGlvbiB0byBnZXQgdGhlIFN1cGFiYXNlIGNsaWVudFxyXG5leHBvcnQgY29uc3QgZ2V0U3VwYWJhc2VDbGllbnQgPSAoKSA9PiB7XHJcbiAgaWYgKCFzdXBhYmFzZUNsaWVudCkge1xyXG4gICAgLy8gUmV0dXJuIG1vY2sgY2xpZW50IGlmIGFjdHVhbCBjbGllbnQgaXNuJ3QgYXZhaWxhYmxlXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBmcm9tOiAodGFibGU6IHN0cmluZykgPT4ge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBzZWxlY3Q6IChjb2x1bW5zOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICBkYXRhOiB0YWJsZSA9PT0gJ3ZpbGxhcycgPyBtb2NrVmlsbGFzIDogbW9ja0Jvb2tpbmdzLFxyXG4gICAgICAgICAgICAgIGVycm9yOiBudWxsLFxyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIC8vIE1vY2sgc3VwYWJhc2UgcXVlcnkgbWV0aG9kc1xyXG4gICAgICAgICAgICAgIGVxOiAoY29sdW1uOiBzdHJpbmcsIHZhbHVlOiBhbnkpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBmaWx0ZXJlZDogKFZpbGxhIHwgQm9va2luZylbXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRhYmxlID09PSAndmlsbGFzJykge1xyXG4gICAgICAgICAgICAgICAgICBmaWx0ZXJlZCA9IG1vY2tWaWxsYXMuZmlsdGVyKChpdGVtOiBWaWxsYSkgPT4gaXRlbVtjb2x1bW4gYXMga2V5b2YgVmlsbGFdID09PSB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhYmxlID09PSAnYm9va2luZ3MnKSB7XHJcbiAgICAgICAgICAgICAgICAgIGZpbHRlcmVkID0gbW9ja0Jvb2tpbmdzLmZpbHRlcigoaXRlbTogQm9va2luZykgPT4gaXRlbVtjb2x1bW4gYXMga2V5b2YgQm9va2luZ10gPT09IHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgZGF0YTogZmlsdGVyZWQsXHJcbiAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICBzaW5nbGU6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgZGF0YTogZmlsdGVyZWQubGVuZ3RoID4gMCA/IGZpbHRlcmVkWzBdIDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBmaWx0ZXJlZC5sZW5ndGggPiAwID8gbnVsbCA6IHsgbWVzc2FnZTogJ05vdCBmb3VuZCcgfVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGluc2VydDogKGRhdGE6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdJdGVtID0ge1xyXG4gICAgICAgICAgICAgIGlkOiBgbW9jay0ke0RhdGUubm93KCl9YCxcclxuICAgICAgICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgICAgICAgICAgLi4uZGF0YVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKHRhYmxlID09PSAndmlsbGFzJykge1xyXG4gICAgICAgICAgICAgIG1vY2tWaWxsYXMucHVzaChuZXdJdGVtKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0YWJsZSA9PT0gJ2Jvb2tpbmdzJykge1xyXG4gICAgICAgICAgICAgIG1vY2tCb29raW5ncy5wdXNoKG5ld0l0ZW0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgIGRhdGE6IG5ld0l0ZW0sXHJcbiAgICAgICAgICAgICAgZXJyb3I6IG51bGxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB1cGRhdGU6IChkYXRhOiBhbnkpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICBtYXRjaDogKHsgaWQgfTogeyBpZDogc3RyaW5nIH0pID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0YWJsZSA9PT0gJ3ZpbGxhcycpIHtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBtb2NrVmlsbGFzLmZpbmRJbmRleCgoaXRlbTogYW55KSA9PiBpdGVtLmlkID09PSBpZCk7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBtb2NrVmlsbGFzW2luZGV4XSA9IHsgLi4ubW9ja1ZpbGxhc1tpbmRleF0sIC4uLmRhdGEgfTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBtb2NrVmlsbGFzW2luZGV4XSwgZXJyb3I6IG51bGwgfTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0YWJsZSA9PT0gJ2Jvb2tpbmdzJykge1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IG1vY2tCb29raW5ncy5maW5kSW5kZXgoKGl0ZW06IGFueSkgPT4gaXRlbS5pZCA9PT0gaWQpO1xyXG4gICAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbW9ja0Jvb2tpbmdzW2luZGV4XSA9IHsgLi4ubW9ja0Jvb2tpbmdzW2luZGV4XSwgLi4uZGF0YSB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG1vY2tCb29raW5nc1tpbmRleF0sIGVycm9yOiBudWxsIH07XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IHsgbWVzc2FnZTogJ0l0ZW0gbm90IGZvdW5kJyB9IH07XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGRlbGV0ZTogKCkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgIG1hdGNoOiAoeyBpZCB9OiB7IGlkOiBzdHJpbmcgfSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRhYmxlID09PSAndmlsbGFzJykge1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IG1vY2tWaWxsYXMuZmluZEluZGV4KChpdGVtOiBhbnkpID0+IGl0ZW0uaWQgPT09IGlkKTtcclxuICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlbGV0ZWQgPSBtb2NrVmlsbGFzW2luZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICBtb2NrVmlsbGFzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogZGVsZXRlZCwgZXJyb3I6IG51bGwgfTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0YWJsZSA9PT0gJ2Jvb2tpbmdzJykge1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IG1vY2tCb29raW5ncy5maW5kSW5kZXgoKGl0ZW06IGFueSkgPT4gaXRlbS5pZCA9PT0gaWQpO1xyXG4gICAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVsZXRlZCA9IG1vY2tCb29raW5nc1tpbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgbW9ja0Jvb2tpbmdzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogZGVsZXRlZCwgZXJyb3I6IG51bGwgfTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogeyBtZXNzYWdlOiAnSXRlbSBub3QgZm91bmQnIH0gfTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcbiAgcmV0dXJuIHN1cGFiYXNlQ2xpZW50O1xyXG59O1xyXG5cclxuY29uc3Qgc3VwYWJhc2UgPSBnZXRTdXBhYmFzZUNsaWVudCgpO1xyXG5leHBvcnQgZGVmYXVsdCBzdXBhYmFzZTtcclxuXHJcbi8vIEhlbHBlciBmdW5jdGlvbiB0byBmZXRjaCBhIHZpbGxhIGJ5IElEXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRWaWxsYUJ5SWQoaWQ6IHN0cmluZyk6IFByb21pc2U8VmlsbGEgfCBudWxsPiB7XHJcbiAgdHJ5IHtcclxuICAgIGlmIChzdXBhYmFzZUNsaWVudCkge1xyXG4gICAgICAvLyBVc2UgdHlwZSBhc3NlcnRpb24gdG8gc2F0aXNmeSBUeXBlU2NyaXB0XHJcbiAgICAgIGNvbnN0IHF1ZXJ5ID0gc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgndmlsbGFzJylcclxuICAgICAgICAuc2VsZWN0KCcqJykgYXMgYW55O1xyXG4gICAgICAgIFxyXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBxdWVyeVxyXG4gICAgICAgIC5lcSgnaWQnLCBpZClcclxuICAgICAgICAuc2luZ2xlKCk7XHJcbiAgICAgICAgXHJcbiAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHZpbGxhOicsIGVycm9yKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgcmV0dXJuIGRhdGEgYXMgVmlsbGE7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBGb3IgbW9jayBpbXBsZW1lbnRhdGlvblxyXG4gICAgICBjb25zdCB2aWxsYSA9IG1vY2tWaWxsYXMuZmluZCh2ID0+IHYuaWQgPT09IGlkKTtcclxuICAgICAgcmV0dXJuIHZpbGxhIHx8IG51bGw7XHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHZpbGxhOicsIGVycm9yKTtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIG5ldyBib29raW5nXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVCb29raW5nKGJvb2tpbmdEYXRhOiBPbWl0PEJvb2tpbmcsICdpZCcgfCAnY3JlYXRlZF9hdCc+KSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnNvbGUubG9nKCdTdWJtaXR0aW5nIGJvb2tpbmcgZGF0YSB0byBTdXBhYmFzZTonLCBib29raW5nRGF0YSk7XHJcbiAgICBcclxuICAgIGlmIChzdXBhYmFzZUNsaWVudCkge1xyXG4gICAgICBjb25zb2xlLmxvZygnVXNpbmcgcmVhbCBTdXBhYmFzZSBjbGllbnQgZm9yIGJvb2tpbmcgY3JlYXRpb24nKTtcclxuICAgICAgXHJcbiAgICAgIC8vIFVzZSB0eXBlIGFzc2VydGlvbiB0byBzYXRpc2Z5IFR5cGVTY3JpcHRcclxuICAgICAgY29uc3QgcXVlcnkgPSBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKCdib29raW5ncycpXHJcbiAgICAgICAgLmluc2VydChbXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIC4uLmJvb2tpbmdEYXRhLFxyXG4gICAgICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIF0pIGFzIGFueTtcclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKCdQcmVwYXJlZCBpbnNlcnQgcXVlcnkgZm9yIGJvb2tpbmdzIHRhYmxlJyk7XHJcbiAgICAgIFxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHF1ZXJ5LnNlbGVjdCgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcignU3VwYWJhc2UgZXJyb3IgZGV0YWlsczonLCB7XHJcbiAgICAgICAgICAgIGNvZGU6IGVycm9yLmNvZGUsXHJcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgIGRldGFpbHM6IGVycm9yLmRldGFpbHMsXHJcbiAgICAgICAgICAgIGhpbnQ6IGVycm9yLmhpbnRcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zb2xlLmxvZygnQm9va2luZyBjcmVhdGVkIHN1Y2Nlc3NmdWxseTonLCBkYXRhKTtcclxuICAgICAgICByZXR1cm4gZGF0YVswXSBhcyBCb29raW5nO1xyXG4gICAgICB9IGNhdGNoIChxdWVyeUVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignU3VwYWJhc2UgcXVlcnkgZXhlY3V0aW9uIGVycm9yOicsIHF1ZXJ5RXJyb3IpO1xyXG4gICAgICAgIHRocm93IHF1ZXJ5RXJyb3I7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIEZvciBtb2NrIGltcGxlbWVudGF0aW9uLCBjcmVhdGUgYSBmYWtlIElEIGFuZCByZXR1cm4gdGhlIGJvb2tpbmdcclxuICAgICAgY29uc29sZS5sb2coJ1VzaW5nIG1vY2sgaW1wbGVtZW50YXRpb24gZm9yIGJvb2tpbmcgY3JlYXRpb24nKTtcclxuICAgICAgY29uc3QgbmV3Qm9va2luZyA9IHtcclxuICAgICAgICAuLi5ib29raW5nRGF0YSxcclxuICAgICAgICBpZDogYG1vY2stJHtEYXRlLm5vdygpfWAsXHJcbiAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcbiAgICAgIH0gYXMgQm9va2luZztcclxuICAgICAgXHJcbiAgICAgIG1vY2tCb29raW5ncy5wdXNoKG5ld0Jvb2tpbmcpO1xyXG4gICAgICBjb25zb2xlLmxvZygnTW9jayBib29raW5nIGNyZWF0ZWQ6JywgbmV3Qm9va2luZyk7XHJcbiAgICAgIHJldHVybiBuZXdCb29raW5nO1xyXG4gICAgfVxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBib29raW5nOicsIGVycm9yKTtcclxuICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufVxyXG5cclxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNoZWNrIHZpbGxhIGF2YWlsYWJpbGl0eVxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2hlY2tWaWxsYUF2YWlsYWJpbGl0eShcclxuICB2aWxsYUlkOiBzdHJpbmcsXHJcbiAgY2hlY2tJbjogc3RyaW5nLFxyXG4gIGNoZWNrT3V0OiBzdHJpbmdcclxuKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgdHJ5IHtcclxuICAgIC8vIEZvciBTdXBhYmFzZSBjbGllbnRcclxuICAgIGlmIChzdXBhYmFzZUNsaWVudCkge1xyXG4gICAgICAvLyBVc2UgdHlwZSBhc3NlcnRpb24gdG8gc2F0aXNmeSBUeXBlU2NyaXB0XHJcbiAgICAgIGNvbnN0IHF1ZXJ5ID0gc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgnYm9va2luZ3MnKVxyXG4gICAgICAgIC5zZWxlY3QoJyonKSBhcyBhbnk7XHJcbiAgICAgICAgXHJcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHF1ZXJ5XHJcbiAgICAgICAgLmVxKCd2aWxsYV9pZCcsIHZpbGxhSWQpXHJcbiAgICAgICAgLmVxKCdzdGF0dXMnLCAnY29uZmlybWVkJyk7XHJcblxyXG4gICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBhdmFpbGFiaWxpdHk6JywgZXJyb3IpO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGJvb2tpbmdzIGZvciB0aGlzIHZpbGxhLCBpdCdzIGF2YWlsYWJsZVxyXG4gICAgICBpZiAoIWRhdGEgfHwgZGF0YS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUgYXJlIGFueSBvdmVybGFwcGluZyBib29raW5nc1xyXG4gICAgICBjb25zdCBib29raW5ncyA9IGRhdGEgYXMgQm9va2luZ1tdO1xyXG4gICAgICBjb25zdCBoYXNPdmVybGFwID0gYm9va2luZ3Muc29tZShib29raW5nID0+IHtcclxuICAgICAgICBjb25zdCBib29raW5nU3RhcnQgPSBuZXcgRGF0ZShib29raW5nLmNoZWNrX2luKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgY29uc3QgYm9va2luZ0VuZCA9IG5ldyBEYXRlKGJvb2tpbmcuY2hlY2tfb3V0KS5nZXRUaW1lKCk7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdFN0YXJ0ID0gbmV3IERhdGUoY2hlY2tJbikuZ2V0VGltZSgpO1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3RFbmQgPSBuZXcgRGF0ZShjaGVja091dCkuZ2V0VGltZSgpO1xyXG5cclxuICAgICAgICByZXR1cm4gKHJlcXVlc3RTdGFydCA8PSBib29raW5nRW5kICYmIHJlcXVlc3RFbmQgPj0gYm9va2luZ1N0YXJ0KTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gb3ZlcmxhcHBpbmcgYm9va2luZ3MsIHRoZSB2aWxsYSBpcyBhdmFpbGFibGVcclxuICAgICAgcmV0dXJuICFoYXNPdmVybGFwO1xyXG4gICAgfSBcclxuICAgIC8vIEZvciBtb2NrIGltcGxlbWVudGF0aW9uXHJcbiAgICBlbHNlIHtcclxuICAgICAgLy8gRmlsdGVyIGJvb2tpbmdzIG1hbnVhbGx5IGZvciB0aGUgbW9jayBpbXBsZW1lbnRhdGlvblxyXG4gICAgICBjb25zdCBjb25maXJtZWRCb29raW5ncyA9IG1vY2tCb29raW5ncy5maWx0ZXIoXHJcbiAgICAgICAgYm9va2luZyA9PiBib29raW5nLnZpbGxhX2lkID09PSB2aWxsYUlkICYmIGJvb2tpbmcuc3RhdHVzID09PSAnY29uZmlybWVkJ1xyXG4gICAgICApO1xyXG4gICAgICBcclxuICAgICAgaWYgKGNvbmZpcm1lZEJvb2tpbmdzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBDaGVjayBmb3Igb3ZlcmxhcHBpbmcgYm9va2luZ3NcclxuICAgICAgY29uc3QgaGFzT3ZlcmxhcCA9IGNvbmZpcm1lZEJvb2tpbmdzLnNvbWUoYm9va2luZyA9PiB7XHJcbiAgICAgICAgY29uc3QgYm9va2luZ1N0YXJ0ID0gbmV3IERhdGUoYm9va2luZy5jaGVja19pbikuZ2V0VGltZSgpO1xyXG4gICAgICAgIGNvbnN0IGJvb2tpbmdFbmQgPSBuZXcgRGF0ZShib29raW5nLmNoZWNrX291dCkuZ2V0VGltZSgpO1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3RTdGFydCA9IG5ldyBEYXRlKGNoZWNrSW4pLmdldFRpbWUoKTtcclxuICAgICAgICBjb25zdCByZXF1ZXN0RW5kID0gbmV3IERhdGUoY2hlY2tPdXQpLmdldFRpbWUoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIChyZXF1ZXN0U3RhcnQgPD0gYm9va2luZ0VuZCAmJiByZXF1ZXN0RW5kID49IGJvb2tpbmdTdGFydCk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBcclxuICAgICAgcmV0dXJuICFoYXNPdmVybGFwO1xyXG4gICAgfVxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBhdmFpbGFiaWxpdHk6JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufVxyXG5cclxuLy8gQXR0ZW1wdCB0byBsb2FkIG1vY2sgZGF0YSBmcm9tIHB1YmxpYyBVUkxcclxuZXhwb3J0IGNvbnN0IGxvYWRNb2NrRGF0YSA9IGFzeW5jICgpID0+IHtcclxuICB0cnkge1xyXG4gICAgLy8gSW4gYSByZWFsIGFwcCwgeW91IHdvdWxkIGZldGNoIHRoaXMgZnJvbSBhbiBBUEkgZW5kcG9pbnRcclxuICAgIC8vIEZvciBub3csIHdlJ2xsIGp1c3QgdXNlIHNvbWUgaGFyZGNvZGVkIGRhdGFcclxuICAgIG1vY2tWaWxsYXMgPSBbXHJcbiAgICAgIHtcclxuICAgICAgICBpZDogXCI1NTBlODQwMC1lMjliLTQxZDQtYTcxNi00NDY2NTU0NDAwMDBcIixcclxuICAgICAgICBuYW1lOiBcIkx1eHVyeSBCZWFjaGZyb250IFZpbGxhXCIsXHJcbiAgICAgICAgZGVzY3JpcHRpb246IFwiRXhwZXJpZW5jZSB0aGUgdWx0aW1hdGUgbHV4dXJ5IGdldGF3YXkgYXQgb3VyIHN0dW5uaW5nIGJlYWNoZnJvbnQgdmlsbGEuIE5lc3RsZWQgb24gdGhlIHByaXN0aW5lIHNob3JlcyBvZiBhIHByaXZhdGUgYmVhY2gsIHRoaXMgZXhxdWlzaXRlIHByb3BlcnR5IG9mZmVycyBicmVhdGh0YWtpbmcgb2NlYW4gdmlld3MgZnJvbSBldmVyeSBhbmdsZS5cIixcclxuICAgICAgICBzaG9ydF9kZXNjcmlwdGlvbjogXCJTdHVubmluZyBiZWFjaGZyb250IHZpbGxhIHdpdGggcHJpdmF0ZSBwb29sLCBkaXJlY3QgYmVhY2ggYWNjZXNzLCBhbmQgYnJlYXRodGFraW5nIG9jZWFuIHZpZXdzLlwiLFxyXG4gICAgICAgIGxvY2F0aW9uOiBcIk1hbGlidSwgQ2FsaWZvcm5pYVwiLFxyXG4gICAgICAgIHByaWNlOiAxMjAwLjAwLFxyXG4gICAgICAgIGJlZHJvb21zOiA1LFxyXG4gICAgICAgIGJhdGhyb29tczogNixcclxuICAgICAgICBtYXhfZ3Vlc3RzOiAxMixcclxuICAgICAgICBpbWFnZXM6IFtcclxuICAgICAgICAgIFwiL2ltYWdlcy92aWxsYS1leHRlcmlvci5qcGdcIixcclxuICAgICAgICAgIFwiL2ltYWdlcy92aWxsYS1pbnRlcmlvci0xLmpwZ1wiLFxyXG4gICAgICAgICAgXCIvaW1hZ2VzL3ZpbGxhLWludGVyaW9yLTIuanBnXCIsXHJcbiAgICAgICAgICBcIi9pbWFnZXMvdmlsbGEtYmVkcm9vbS5qcGdcIixcclxuICAgICAgICAgIFwiL2ltYWdlcy92aWxsYS1iYXRocm9vbS5qcGdcIixcclxuICAgICAgICAgIFwiL2ltYWdlcy92aWxsYS1wb29sLmpwZ1wiLFxyXG4gICAgICAgICAgXCIvaW1hZ2VzL3ZpbGxhLWJlYWNoLmpwZ1wiLFxyXG4gICAgICAgICAgXCIvaW1hZ2VzL3ZpbGxhLWRpbmluZy5qcGdcIlxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgYW1lbml0aWVzOiBbXHJcbiAgICAgICAgICBcIlByaXZhdGUgUG9vbFwiLFxyXG4gICAgICAgICAgXCJEaXJlY3QgQmVhY2ggQWNjZXNzXCIsXHJcbiAgICAgICAgICBcIk9jZWFuIFZpZXdcIixcclxuICAgICAgICAgIFwiRnVsbHkgRXF1aXBwZWQgS2l0Y2hlblwiLFxyXG4gICAgICAgICAgXCJBaXIgQ29uZGl0aW9uaW5nXCIsXHJcbiAgICAgICAgICBcIkZyZWUgV2lGaVwiLFxyXG4gICAgICAgICAgXCJTbWFydCBUVlwiLFxyXG4gICAgICAgICAgXCJPdXRkb29yIERpbmluZyBBcmVhXCIsXHJcbiAgICAgICAgICBcIkJCUSBHcmlsbFwiLFxyXG4gICAgICAgICAgXCJQYXJraW5nXCIsXHJcbiAgICAgICAgICBcIkd5bVwiLFxyXG4gICAgICAgICAgXCJIb21lIFRoZWF0ZXJcIixcclxuICAgICAgICAgIFwiTGF1bmRyeSBGYWNpbGl0aWVzXCIsXHJcbiAgICAgICAgICBcIjI0LzcgU2VjdXJpdHlcIixcclxuICAgICAgICAgIFwiQ29uY2llcmdlIFNlcnZpY2VcIlxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcbiAgICAgIH1cclxuICAgIF07XHJcbiAgICBcclxuICAgIG1vY2tCb29raW5ncyA9IFtdO1xyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZygnTW9jayBkYXRhIGxvYWRlZCBzdWNjZXNzZnVsbHknKTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBtb2NrIGRhdGE6JywgZXJyb3IpO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIExvYWQgbW9jayBkYXRhIG9uIGluaXRpYWxpemF0aW9uXHJcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAoIXN1cGFiYXNlVXJsIHx8ICFzdXBhYmFzZUtleSkpIHtcclxuICBsb2FkTW9ja0RhdGEoKTtcclxufVxyXG5cclxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHRlc3QgU3VwYWJhc2UgY29ubmVjdGlvblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdGVzdFN1cGFiYXNlQ29ubmVjdGlvbigpIHtcclxuICB0cnkge1xyXG4gICAgY29uc29sZS5sb2coJ1Rlc3RpbmcgU3VwYWJhc2UgY29ubmVjdGlvbi4uLicpO1xyXG4gICAgXHJcbiAgICBpZiAoc3VwYWJhc2VDbGllbnQpIHtcclxuICAgICAgLy8gVXNlIGFjdHVhbCBTdXBhYmFzZSBjbGllbnRcclxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VDbGllbnRcclxuICAgICAgICAuZnJvbSgndmlsbGFzJylcclxuICAgICAgICAuc2VsZWN0KCdpZCwgbmFtZScpXHJcbiAgICAgICAgLmxpbWl0KDEpO1xyXG4gICAgICAgIFxyXG4gICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdTdXBhYmFzZSBjb25uZWN0aW9uIHRlc3QgZmFpbGVkOicsIGVycm9yKTtcclxuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coJ1N1cGFiYXNlIGNvbm5lY3Rpb24gc3VjY2Vzc2Z1bDonLCBkYXRhKTtcclxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZGF0YSB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gVXNpbmcgbW9jayBpbXBsZW1lbnRhdGlvblxyXG4gICAgICBjb25zb2xlLndhcm4oJ1N1cGFiYXNlIGNsaWVudCBub3QgaW5pdGlhbGl6ZWQsIHVzaW5nIG1vY2sgZGF0YScpO1xyXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdTdXBhYmFzZSBjbGllbnQgbm90IGluaXRpYWxpemVkJyB9O1xyXG4gICAgfVxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB0ZXN0aW5nIFN1cGFiYXNlIGNvbm5lY3Rpb246JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBTdHJpbmcoZXJyb3IpIH07XHJcbiAgfVxyXG59ICJdLCJuYW1lcyI6WyJjcmVhdGVDbGllbnQiLCJtb2NrVmlsbGFzIiwibW9ja0Jvb2tpbmdzIiwic3VwYWJhc2VVcmwiLCJzdXBhYmFzZUtleSIsInN1cGFiYXNlQ2xpZW50IiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZIiwiY29uc29sZSIsImxvZyIsInVybERlZmluZWQiLCJrZXlEZWZpbmVkIiwidXJsVmFsdWUiLCJzdWJzdHJpbmciLCJrZXlWYWx1ZSIsIndhcm4iLCJlcnJvciIsImdldFN1cGFiYXNlQ2xpZW50IiwiZnJvbSIsInRhYmxlIiwic2VsZWN0IiwiY29sdW1ucyIsImRhdGEiLCJlcSIsImNvbHVtbiIsInZhbHVlIiwiZmlsdGVyZWQiLCJmaWx0ZXIiLCJpdGVtIiwic2luZ2xlIiwibGVuZ3RoIiwibWVzc2FnZSIsImluc2VydCIsIm5ld0l0ZW0iLCJpZCIsIkRhdGUiLCJub3ciLCJjcmVhdGVkX2F0IiwidG9JU09TdHJpbmciLCJwdXNoIiwidXBkYXRlIiwibWF0Y2giLCJpbmRleCIsImZpbmRJbmRleCIsImRlbGV0ZSIsImRlbGV0ZWQiLCJzcGxpY2UiLCJzdXBhYmFzZSIsImdldFZpbGxhQnlJZCIsInF1ZXJ5IiwidmlsbGEiLCJmaW5kIiwidiIsImNyZWF0ZUJvb2tpbmciLCJib29raW5nRGF0YSIsImNvZGUiLCJkZXRhaWxzIiwiaGludCIsInF1ZXJ5RXJyb3IiLCJuZXdCb29raW5nIiwiY2hlY2tWaWxsYUF2YWlsYWJpbGl0eSIsInZpbGxhSWQiLCJjaGVja0luIiwiY2hlY2tPdXQiLCJib29raW5ncyIsImhhc092ZXJsYXAiLCJzb21lIiwiYm9va2luZyIsImJvb2tpbmdTdGFydCIsImNoZWNrX2luIiwiZ2V0VGltZSIsImJvb2tpbmdFbmQiLCJjaGVja19vdXQiLCJyZXF1ZXN0U3RhcnQiLCJyZXF1ZXN0RW5kIiwiY29uZmlybWVkQm9va2luZ3MiLCJ2aWxsYV9pZCIsInN0YXR1cyIsImxvYWRNb2NrRGF0YSIsIm5hbWUiLCJkZXNjcmlwdGlvbiIsInNob3J0X2Rlc2NyaXB0aW9uIiwibG9jYXRpb24iLCJwcmljZSIsImJlZHJvb21zIiwiYmF0aHJvb21zIiwibWF4X2d1ZXN0cyIsImltYWdlcyIsImFtZW5pdGllcyIsInRlc3RTdXBhYmFzZUNvbm5lY3Rpb24iLCJsaW1pdCIsInN1Y2Nlc3MiLCJTdHJpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./utils/supabase.ts\n"));

/***/ })

});