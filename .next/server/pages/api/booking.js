"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/booking";
exports.ids = ["pages/api/booking"];
exports.modules = {

/***/ "@supabase/supabase-js":
/*!****************************************!*\
  !*** external "@supabase/supabase-js" ***!
  \****************************************/
/***/ ((module) => {

module.exports = require("@supabase/supabase-js");

/***/ }),

/***/ "next/dist/compiled/next-server/pages-api.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages-api.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/pages-api.runtime.dev.js");

/***/ }),

/***/ "(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fbooking&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Fbooking.ts&middlewareConfigBase64=e30%3D!":
/*!********************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fbooking&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Fbooking.ts&middlewareConfigBase64=e30%3D! ***!
  \********************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   routeModule: () => (/* binding */ routeModule)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/pages-api/module.compiled */ \"(api)/./node_modules/next/dist/server/future/route-modules/pages-api/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(api)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/build/templates/helpers */ \"(api)/./node_modules/next/dist/build/templates/helpers.js\");\n/* harmony import */ var _pages_api_booking_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pages/api/booking.ts */ \"(api)/./pages/api/booking.ts\");\n\n\n\n// Import the userland code.\n\n// Re-export the handler (should be the default export).\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_booking_ts__WEBPACK_IMPORTED_MODULE_3__, \"default\"));\n// Re-export config.\nconst config = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_booking_ts__WEBPACK_IMPORTED_MODULE_3__, \"config\");\n// Create and export the route module that will be consumed.\nconst routeModule = new next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__.PagesAPIRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.PAGES_API,\n        page: \"/api/booking\",\n        pathname: \"/api/booking\",\n        // The following aren't used in production.\n        bundlePath: \"\",\n        filename: \"\"\n    },\n    userland: _pages_api_booking_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n\n//# sourceMappingURL=pages-api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXJvdXRlLWxvYWRlci9pbmRleC5qcz9raW5kPVBBR0VTX0FQSSZwYWdlPSUyRmFwaSUyRmJvb2tpbmcmcHJlZmVycmVkUmVnaW9uPSZhYnNvbHV0ZVBhZ2VQYXRoPS4lMkZwYWdlcyUyRmFwaSUyRmJvb2tpbmcudHMmbWlkZGxld2FyZUNvbmZpZ0Jhc2U2ND1lMzAlM0QhIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQXNHO0FBQ3ZDO0FBQ0w7QUFDMUQ7QUFDbUQ7QUFDbkQ7QUFDQSxpRUFBZSx3RUFBSyxDQUFDLGtEQUFRLFlBQVksRUFBQztBQUMxQztBQUNPLGVBQWUsd0VBQUssQ0FBQyxrREFBUTtBQUNwQztBQUNPLHdCQUF3QixnSEFBbUI7QUFDbEQ7QUFDQSxjQUFjLHlFQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWTtBQUNaLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aWxsYS1ib29raW5nLz85MjdlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBhZ2VzQVBJUm91dGVNb2R1bGUgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9mdXR1cmUvcm91dGUtbW9kdWxlcy9wYWdlcy1hcGkvbW9kdWxlLmNvbXBpbGVkXCI7XG5pbXBvcnQgeyBSb3V0ZUtpbmQgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9mdXR1cmUvcm91dGUta2luZFwiO1xuaW1wb3J0IHsgaG9pc3QgfSBmcm9tIFwibmV4dC9kaXN0L2J1aWxkL3RlbXBsYXRlcy9oZWxwZXJzXCI7XG4vLyBJbXBvcnQgdGhlIHVzZXJsYW5kIGNvZGUuXG5pbXBvcnQgKiBhcyB1c2VybGFuZCBmcm9tIFwiLi9wYWdlcy9hcGkvYm9va2luZy50c1wiO1xuLy8gUmUtZXhwb3J0IHRoZSBoYW5kbGVyIChzaG91bGQgYmUgdGhlIGRlZmF1bHQgZXhwb3J0KS5cbmV4cG9ydCBkZWZhdWx0IGhvaXN0KHVzZXJsYW5kLCBcImRlZmF1bHRcIik7XG4vLyBSZS1leHBvcnQgY29uZmlnLlxuZXhwb3J0IGNvbnN0IGNvbmZpZyA9IGhvaXN0KHVzZXJsYW5kLCBcImNvbmZpZ1wiKTtcbi8vIENyZWF0ZSBhbmQgZXhwb3J0IHRoZSByb3V0ZSBtb2R1bGUgdGhhdCB3aWxsIGJlIGNvbnN1bWVkLlxuZXhwb3J0IGNvbnN0IHJvdXRlTW9kdWxlID0gbmV3IFBhZ2VzQVBJUm91dGVNb2R1bGUoe1xuICAgIGRlZmluaXRpb246IHtcbiAgICAgICAga2luZDogUm91dGVLaW5kLlBBR0VTX0FQSSxcbiAgICAgICAgcGFnZTogXCIvYXBpL2Jvb2tpbmdcIixcbiAgICAgICAgcGF0aG5hbWU6IFwiL2FwaS9ib29raW5nXCIsXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgYXJlbid0IHVzZWQgaW4gcHJvZHVjdGlvbi5cbiAgICAgICAgYnVuZGxlUGF0aDogXCJcIixcbiAgICAgICAgZmlsZW5hbWU6IFwiXCJcbiAgICB9LFxuICAgIHVzZXJsYW5kXG59KTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFnZXMtYXBpLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fbooking&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Fbooking.ts&middlewareConfigBase64=e30%3D!\n");

/***/ }),

/***/ "(api)/./pages/api/booking.ts":
/*!******************************!*\
  !*** ./pages/api/booking.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ handler)\n/* harmony export */ });\n/* harmony import */ var _utils_supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/supabase */ \"(api)/./utils/supabase.ts\");\n\n// Remove duplicate client creation - we'll use getSupabaseClient instead\n// which handles service key vs anon key appropriately\nasync function processPayment(amount) {\n    try {\n        // In a real app, you'd call your payment processor (Stripe, etc.)\n        // For now, we'll just generate a mock payment ID\n        await new Promise((resolve)=>setTimeout(resolve, 500)); // Simulate processing time\n        return `pay_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`;\n    } catch (error) {\n        console.error(\"Payment processing error:\", error);\n        throw new Error(\"Payment processing failed\");\n    }\n}\nasync function handler(req, res) {\n    // Get the admin client with service role for higher permissions\n    const supabase = (0,_utils_supabase__WEBPACK_IMPORTED_MODULE_0__.getSupabaseClient)(true); // Pass true to get admin client\n    // Only allow POST requests\n    if (req.method !== \"POST\") {\n        res.setHeader(\"Allow\", [\n            \"POST\"\n        ]);\n        return res.status(405).end(`Method ${req.method} Not Allowed`);\n    }\n    try {\n        const bookingData = req.body;\n        // Log the received data for debugging\n        console.log(\"API received booking data:\", bookingData);\n        // Validate required fields\n        const requiredFields = [\n            \"first_name\",\n            \"last_name\",\n            \"email\",\n            \"phone\",\n            \"check_in\",\n            \"check_out\",\n            \"guests\",\n            \"villa_id\",\n            \"total_amount\"\n        ];\n        const missingFields = requiredFields.filter((field)=>!bookingData[field]);\n        if (missingFields.length > 0) {\n            return res.status(400).json({\n                success: false,\n                error: `Missing required fields: ${missingFields.join(\", \")}`\n            });\n        }\n        // 1. Process payment first\n        console.log(\"Processing payment for amount:\", bookingData.total_amount);\n        let paymentId;\n        try {\n            paymentId = await processPayment(bookingData.total_amount);\n            console.log(\"Payment processed successfully:\", paymentId);\n        } catch (paymentError) {\n            console.error(\"Payment processing failed:\", paymentError);\n            return res.status(400).json({\n                success: false,\n                error: \"Payment processing failed\",\n                details: paymentError instanceof Error ? paymentError.message : String(paymentError)\n            });\n        }\n        // 2. If payment is successful, create booking\n        const bookingWithPayment = {\n            ...bookingData,\n            payment_id: paymentId,\n            status: \"confirmed\"\n        };\n        console.log(\"Creating booking with payment ID:\", paymentId);\n        try {\n            // Pass the admin client to ensure it uses the service role\n            const booking = await (0,_utils_supabase__WEBPACK_IMPORTED_MODULE_0__.createBooking)(bookingWithPayment, supabase);\n            // Return success response\n            return res.status(201).json({\n                success: true,\n                booking,\n                payment: {\n                    id: paymentId,\n                    amount: bookingData.total_amount,\n                    status: \"completed\"\n                },\n                message: \"Booking created successfully\"\n            });\n        } catch (bookingError) {\n            console.error(\"Error creating booking after payment:\", bookingError);\n            return res.status(500).json({\n                success: false,\n                error: \"Failed to create booking after successful payment\",\n                payment_id: paymentId,\n                details: bookingError instanceof Error ? bookingError.message : String(bookingError)\n            });\n        }\n    } catch (error) {\n        console.error(\"Error creating booking:\", error);\n        return res.status(500).json({\n            success: false,\n            error: error instanceof Error ? error.message : \"An unknown error occurred\"\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUF5Q2lDO1lBQ3ZELE9BQU81QixJQUFJSSxNQUFNLENBQUMsS0FBS1UsSUFBSSxDQUFDO2dCQUMxQkMsU0FBUztnQkFDVHBCLE9BQU87Z0JBQ1A2QixZQUFZTjtnQkFDWkUsU0FBU1Esd0JBQXdCL0IsUUFBUStCLGFBQWFQLE9BQU8sR0FBR0MsT0FBT007WUFDekU7UUFDRjtJQUVGLEVBQUUsT0FBT2pDLE9BQU87UUFDZEMsUUFBUUQsS0FBSyxDQUFDLDJCQUEyQkE7UUFFekMsT0FBT0ssSUFBSUksTUFBTSxDQUFDLEtBQUtVLElBQUksQ0FBQztZQUMxQkMsU0FBUztZQUNUcEIsT0FBT0EsaUJBQWlCRSxRQUFRRixNQUFNMEIsT0FBTyxHQUFHO1FBQ2xEO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpbGxhLWJvb2tpbmcvLi9wYWdlcy9hcGkvYm9va2luZy50cz9mZWUyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5leHRBcGlSZXF1ZXN0LCBOZXh0QXBpUmVzcG9uc2UgfSBmcm9tICduZXh0JztcbmltcG9ydCB7IGdldFN1cGFiYXNlQ2xpZW50LCBjcmVhdGVCb29raW5nIH0gZnJvbSAnLi4vLi4vdXRpbHMvc3VwYWJhc2UnO1xuXG4vLyBSZW1vdmUgZHVwbGljYXRlIGNsaWVudCBjcmVhdGlvbiAtIHdlJ2xsIHVzZSBnZXRTdXBhYmFzZUNsaWVudCBpbnN0ZWFkXG4vLyB3aGljaCBoYW5kbGVzIHNlcnZpY2Uga2V5IHZzIGFub24ga2V5IGFwcHJvcHJpYXRlbHlcblxuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1BheW1lbnQoYW1vdW50OiBudW1iZXIpOiBQcm9taXNlPHN0cmluZz4ge1xuICB0cnkge1xuICAgIC8vIEluIGEgcmVhbCBhcHAsIHlvdSdkIGNhbGwgeW91ciBwYXltZW50IHByb2Nlc3NvciAoU3RyaXBlLCBldGMuKVxuICAgIC8vIEZvciBub3csIHdlJ2xsIGp1c3QgZ2VuZXJhdGUgYSBtb2NrIHBheW1lbnQgSURcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7IC8vIFNpbXVsYXRlIHByb2Nlc3NpbmcgdGltZVxuICAgIHJldHVybiBgcGF5XyR7RGF0ZS5ub3coKX1fJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgOCl9YDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdQYXltZW50IHByb2Nlc3NpbmcgZXJyb3I6JywgZXJyb3IpO1xuICAgIHRocm93IG5ldyBFcnJvcignUGF5bWVudCBwcm9jZXNzaW5nIGZhaWxlZCcpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGhhbmRsZXIocmVxOiBOZXh0QXBpUmVxdWVzdCwgcmVzOiBOZXh0QXBpUmVzcG9uc2UpIHtcbiAgLy8gR2V0IHRoZSBhZG1pbiBjbGllbnQgd2l0aCBzZXJ2aWNlIHJvbGUgZm9yIGhpZ2hlciBwZXJtaXNzaW9uc1xuICBjb25zdCBzdXBhYmFzZSA9IGdldFN1cGFiYXNlQ2xpZW50KHRydWUpOyAvLyBQYXNzIHRydWUgdG8gZ2V0IGFkbWluIGNsaWVudFxuICBcbiAgLy8gT25seSBhbGxvdyBQT1NUIHJlcXVlc3RzXG4gIGlmIChyZXEubWV0aG9kICE9PSAnUE9TVCcpIHtcbiAgICByZXMuc2V0SGVhZGVyKCdBbGxvdycsIFsnUE9TVCddKTtcbiAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDUpLmVuZChgTWV0aG9kICR7cmVxLm1ldGhvZH0gTm90IEFsbG93ZWRgKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgYm9va2luZ0RhdGEgPSByZXEuYm9keTtcbiAgICBcbiAgICAvLyBMb2cgdGhlIHJlY2VpdmVkIGRhdGEgZm9yIGRlYnVnZ2luZ1xuICAgIGNvbnNvbGUubG9nKCdBUEkgcmVjZWl2ZWQgYm9va2luZyBkYXRhOicsIGJvb2tpbmdEYXRhKTtcbiAgICBcbiAgICAvLyBWYWxpZGF0ZSByZXF1aXJlZCBmaWVsZHNcbiAgICBjb25zdCByZXF1aXJlZEZpZWxkcyA9IFtcbiAgICAgICdmaXJzdF9uYW1lJywgXG4gICAgICAnbGFzdF9uYW1lJywgXG4gICAgICAnZW1haWwnLCBcbiAgICAgICdwaG9uZScsIFxuICAgICAgJ2NoZWNrX2luJywgXG4gICAgICAnY2hlY2tfb3V0JywgXG4gICAgICAnZ3Vlc3RzJyxcbiAgICAgICd2aWxsYV9pZCcsXG4gICAgICAndG90YWxfYW1vdW50J1xuICAgIF07XG4gICAgXG4gICAgY29uc3QgbWlzc2luZ0ZpZWxkcyA9IHJlcXVpcmVkRmllbGRzLmZpbHRlcihmaWVsZCA9PiAhYm9va2luZ0RhdGFbZmllbGRdKTtcbiAgICBcbiAgICBpZiAobWlzc2luZ0ZpZWxkcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDApLmpzb24oeyBcbiAgICAgICAgc3VjY2VzczogZmFsc2UsIFxuICAgICAgICBlcnJvcjogYE1pc3NpbmcgcmVxdWlyZWQgZmllbGRzOiAke21pc3NpbmdGaWVsZHMuam9pbignLCAnKX1gIFxuICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIC8vIDEuIFByb2Nlc3MgcGF5bWVudCBmaXJzdFxuICAgIGNvbnNvbGUubG9nKCdQcm9jZXNzaW5nIHBheW1lbnQgZm9yIGFtb3VudDonLCBib29raW5nRGF0YS50b3RhbF9hbW91bnQpO1xuICAgIGxldCBwYXltZW50SWQ7XG4gICAgdHJ5IHtcbiAgICAgIHBheW1lbnRJZCA9IGF3YWl0IHByb2Nlc3NQYXltZW50KGJvb2tpbmdEYXRhLnRvdGFsX2Ftb3VudCk7XG4gICAgICBjb25zb2xlLmxvZygnUGF5bWVudCBwcm9jZXNzZWQgc3VjY2Vzc2Z1bGx5OicsIHBheW1lbnRJZCk7XG4gICAgfSBjYXRjaCAocGF5bWVudEVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdQYXltZW50IHByb2Nlc3NpbmcgZmFpbGVkOicsIHBheW1lbnRFcnJvcik7XG4gICAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDApLmpzb24oe1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6ICdQYXltZW50IHByb2Nlc3NpbmcgZmFpbGVkJyxcbiAgICAgICAgZGV0YWlsczogcGF5bWVudEVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBwYXltZW50RXJyb3IubWVzc2FnZSA6IFN0cmluZyhwYXltZW50RXJyb3IpXG4gICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgLy8gMi4gSWYgcGF5bWVudCBpcyBzdWNjZXNzZnVsLCBjcmVhdGUgYm9va2luZ1xuICAgIGNvbnN0IGJvb2tpbmdXaXRoUGF5bWVudCA9IHtcbiAgICAgIC4uLmJvb2tpbmdEYXRhLFxuICAgICAgcGF5bWVudF9pZDogcGF5bWVudElkLFxuICAgICAgc3RhdHVzOiAnY29uZmlybWVkJywgLy8gU2luY2UgcGF5bWVudCB3YXMgc3VjY2Vzc2Z1bCwgbWFyayBhcyBjb25maXJtZWRcbiAgICB9O1xuICAgIFxuICAgIGNvbnNvbGUubG9nKCdDcmVhdGluZyBib29raW5nIHdpdGggcGF5bWVudCBJRDonLCBwYXltZW50SWQpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBQYXNzIHRoZSBhZG1pbiBjbGllbnQgdG8gZW5zdXJlIGl0IHVzZXMgdGhlIHNlcnZpY2Ugcm9sZVxuICAgICAgY29uc3QgYm9va2luZyA9IGF3YWl0IGNyZWF0ZUJvb2tpbmcoYm9va2luZ1dpdGhQYXltZW50LCBzdXBhYmFzZSk7XG4gICAgICBcbiAgICAgIC8vIFJldHVybiBzdWNjZXNzIHJlc3BvbnNlXG4gICAgICByZXR1cm4gcmVzLnN0YXR1cygyMDEpLmpzb24oeyBcbiAgICAgICAgc3VjY2VzczogdHJ1ZSwgXG4gICAgICAgIGJvb2tpbmcsXG4gICAgICAgIHBheW1lbnQ6IHtcbiAgICAgICAgICBpZDogcGF5bWVudElkLFxuICAgICAgICAgIGFtb3VudDogYm9va2luZ0RhdGEudG90YWxfYW1vdW50LFxuICAgICAgICAgIHN0YXR1czogJ2NvbXBsZXRlZCdcbiAgICAgICAgfSxcbiAgICAgICAgbWVzc2FnZTogJ0Jvb2tpbmcgY3JlYXRlZCBzdWNjZXNzZnVsbHknIFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoYm9va2luZ0Vycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBib29raW5nIGFmdGVyIHBheW1lbnQ6JywgYm9va2luZ0Vycm9yKTtcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKDUwMCkuanNvbih7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogJ0ZhaWxlZCB0byBjcmVhdGUgYm9va2luZyBhZnRlciBzdWNjZXNzZnVsIHBheW1lbnQnLFxuICAgICAgICBwYXltZW50X2lkOiBwYXltZW50SWQsXG4gICAgICAgIGRldGFpbHM6IGJvb2tpbmdFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gYm9va2luZ0Vycm9yLm1lc3NhZ2UgOiBTdHJpbmcoYm9va2luZ0Vycm9yKVxuICAgICAgfSk7XG4gICAgfVxuICAgIFxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIGJvb2tpbmc6JywgZXJyb3IpO1xuICAgIFxuICAgIHJldHVybiByZXMuc3RhdHVzKDUwMCkuanNvbih7IFxuICAgICAgc3VjY2VzczogZmFsc2UsIFxuICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ0FuIHVua25vd24gZXJyb3Igb2NjdXJyZWQnIFxuICAgIH0pO1xuICB9XG59ICJdLCJuYW1lcyI6WyJnZXRTdXBhYmFzZUNsaWVudCIsImNyZWF0ZUJvb2tpbmciLCJwcm9jZXNzUGF5bWVudCIsImFtb3VudCIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsIkRhdGUiLCJub3ciLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHJpbmciLCJlcnJvciIsImNvbnNvbGUiLCJFcnJvciIsImhhbmRsZXIiLCJyZXEiLCJyZXMiLCJzdXBhYmFzZSIsIm1ldGhvZCIsInNldEhlYWRlciIsInN0YXR1cyIsImVuZCIsImJvb2tpbmdEYXRhIiwiYm9keSIsImxvZyIsInJlcXVpcmVkRmllbGRzIiwibWlzc2luZ0ZpZWxkcyIsImZpbHRlciIsImZpZWxkIiwibGVuZ3RoIiwianNvbiIsInN1Y2Nlc3MiLCJqb2luIiwidG90YWxfYW1vdW50IiwicGF5bWVudElkIiwicGF5bWVudEVycm9yIiwiZGV0YWlscyIsIm1lc3NhZ2UiLCJTdHJpbmciLCJib29raW5nV2l0aFBheW1lbnQiLCJwYXltZW50X2lkIiwiYm9va2luZyIsInBheW1lbnQiLCJpZCIsImJvb2tpbmdFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./pages/api/booking.ts\n");

/***/ }),

/***/ "(api)/./utils/supabase.ts":
/*!***************************!*\
  !*** ./utils/supabase.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkVillaAvailability: () => (/* binding */ checkVillaAvailability),\n/* harmony export */   createBooking: () => (/* binding */ createBooking),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   getSupabaseClient: () => (/* binding */ getSupabaseClient),\n/* harmony export */   getVillaById: () => (/* binding */ getVillaById),\n/* harmony export */   loadMockData: () => (/* binding */ loadMockData),\n/* harmony export */   testSupabaseConnection: () => (/* binding */ testSupabaseConnection)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"@supabase/supabase-js\");\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__);\n\n// Mock data for fallback when Supabase isn't available\nlet mockVillas = [];\nlet mockBookings = [];\n// Supabase client initialization\nlet supabaseUrl = \"https://strvmujzcfzqaqoksnlh.supabase.co\";\nlet supabaseAnonKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InN0cnZtdWp6Y2Z6cWFxb2tzbmxoIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDE4NTY3NDEsImV4cCI6MjA1NzQzMjc0MX0.JNKAXzQAHbk9uxrBITPoII_qk2TD5aLSwMtnk5fGzao\";\nlet supabaseServiceKey = process.env.SUPABASE_SERVICE_KEY;\nlet supabaseClient = null;\nlet supabaseAdminClient = null;\n// Log environment variables status\nconsole.log(\"Supabase environment variables status:\", {\n    urlExists: !!supabaseUrl,\n    anonKeyExists: !!supabaseAnonKey,\n    serviceKeyExists: !!supabaseServiceKey\n});\n// Attempt to initialize Supabase client with credentials\nif (supabaseUrl && supabaseAnonKey) {\n    try {\n        console.log(\"Initializing Supabase client with available credentials\");\n        supabaseClient = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey);\n        console.log(\"Supabase client initialized successfully\");\n    } catch (error) {\n        console.error(\"Failed to initialize Supabase client:\", error);\n    }\n}\n// Attempt to initialize admin client in server-side code\nif ( true && supabaseUrl && supabaseServiceKey) {\n    try {\n        console.log(\"Initializing Supabase admin client\");\n        supabaseAdminClient = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseServiceKey, {\n            auth: {\n                autoRefreshToken: false,\n                persistSession: false\n            }\n        });\n        console.log(\"Supabase admin client initialized successfully\");\n    } catch (error) {\n        console.error(\"Failed to initialize Supabase admin client:\", error);\n    }\n}\n// Function to create a mock Supabase client\nfunction createMockClient() {\n    console.warn(\"Creating mock Supabase client\");\n    return {\n        from: (table)=>{\n            return {\n                select: (columns = \"*\")=>{\n                    console.log(`Mock SELECT ${columns} FROM ${table}`);\n                    const mockResult = {\n                        data: table === \"villas\" ? mockVillas : mockBookings,\n                        error: null,\n                        // Add methods that are used in your codebase\n                        eq: function(column, value) {\n                            console.log(`Mock WHERE ${column} = ${value}`);\n                            let filtered = [];\n                            if (table === \"villas\") {\n                                filtered = mockVillas.filter((item)=>item[column] === value);\n                            } else if (table === \"bookings\") {\n                                filtered = mockBookings.filter((item)=>item[column] === value);\n                            }\n                            return {\n                                data: filtered,\n                                error: null,\n                                limit: function(n) {\n                                    console.log(`Mock LIMIT ${n}`);\n                                    return {\n                                        data: filtered.slice(0, n),\n                                        error: null,\n                                        single: function() {\n                                            return {\n                                                data: filtered.length > 0 ? filtered[0] : null,\n                                                error: filtered.length > 0 ? null : {\n                                                    message: \"Not found\"\n                                                }\n                                            };\n                                        }\n                                    };\n                                },\n                                single: function() {\n                                    return {\n                                        data: filtered.length > 0 ? filtered[0] : null,\n                                        error: filtered.length > 0 ? null : {\n                                            message: \"Not found\"\n                                        }\n                                    };\n                                }\n                            };\n                        },\n                        limit: function(n) {\n                            console.log(`Mock LIMIT ${n}`);\n                            const limitedData = (table === \"villas\" ? mockVillas : mockBookings).slice(0, n);\n                            return {\n                                data: limitedData,\n                                error: null\n                            };\n                        }\n                    };\n                    return mockResult;\n                },\n                insert: (data)=>{\n                    console.log(`Mock INSERT INTO ${table}`, data);\n                    const newItem = {\n                        id: `mock-${Date.now()}`,\n                        created_at: new Date().toISOString(),\n                        ...data\n                    };\n                    if (table === \"villas\") {\n                        mockVillas.push(newItem);\n                    } else if (table === \"bookings\") {\n                        mockBookings.push(newItem);\n                    } else if (table === \"transactions\") {\n                        // Handle transactions mock table\n                        console.log(\"Mock transaction created:\", newItem);\n                    }\n                    return {\n                        data: [\n                            newItem\n                        ],\n                        error: null,\n                        select: ()=>({\n                                data: [\n                                    newItem\n                                ],\n                                error: null\n                            })\n                    };\n                },\n                update: (data)=>{\n                    console.log(`Mock UPDATE ${table}`, data);\n                    return {\n                        eq: function(column, value) {\n                            console.log(`Mock WHERE ${column} = ${value}`);\n                            if (table === \"villas\") {\n                                const index = mockVillas.findIndex((item)=>item[column] === value);\n                                if (index !== -1) {\n                                    mockVillas[index] = {\n                                        ...mockVillas[index],\n                                        ...data\n                                    };\n                                    return {\n                                        data: mockVillas[index],\n                                        error: null\n                                    };\n                                }\n                            } else if (table === \"bookings\") {\n                                const index = mockBookings.findIndex((item)=>item[column] === value);\n                                if (index !== -1) {\n                                    mockBookings[index] = {\n                                        ...mockBookings[index],\n                                        ...data\n                                    };\n                                    return {\n                                        data: mockBookings[index],\n                                        error: null\n                                    };\n                                }\n                            }\n                            return {\n                                data: null,\n                                error: {\n                                    message: \"Item not found\"\n                                }\n                            };\n                        },\n                        match: ({ id })=>{\n                            console.log(`Mock WHERE id = ${id}`);\n                            if (table === \"villas\") {\n                                const index = mockVillas.findIndex((item)=>item.id === id);\n                                if (index !== -1) {\n                                    mockVillas[index] = {\n                                        ...mockVillas[index],\n                                        ...data\n                                    };\n                                    return {\n                                        data: mockVillas[index],\n                                        error: null\n                                    };\n                                }\n                            } else if (table === \"bookings\") {\n                                const index = mockBookings.findIndex((item)=>item.id === id);\n                                if (index !== -1) {\n                                    mockBookings[index] = {\n                                        ...mockBookings[index],\n                                        ...data\n                                    };\n                                    return {\n                                        data: mockBookings[index],\n                                        error: null\n                                    };\n                                }\n                            }\n                            return {\n                                data: null,\n                                error: {\n                                    message: \"Item not found\"\n                                }\n                            };\n                        }\n                    };\n                },\n                delete: ()=>{\n                    console.log(`Mock DELETE FROM ${table}`);\n                    return {\n                        match: ({ id })=>{\n                            console.log(`Mock WHERE id = ${id}`);\n                            if (table === \"villas\") {\n                                const index = mockVillas.findIndex((item)=>item.id === id);\n                                if (index !== -1) {\n                                    const deleted = mockVillas[index];\n                                    mockVillas.splice(index, 1);\n                                    return {\n                                        data: deleted,\n                                        error: null\n                                    };\n                                }\n                            } else if (table === \"bookings\") {\n                                const index = mockBookings.findIndex((item)=>item.id === id);\n                                if (index !== -1) {\n                                    const deleted = mockBookings[index];\n                                    mockBookings.splice(index, 1);\n                                    return {\n                                        data: deleted,\n                                        error: null\n                                    };\n                                }\n                            }\n                            return {\n                                data: null,\n                                error: {\n                                    message: \"Item not found\"\n                                }\n                            };\n                        }\n                    };\n                }\n            };\n        }\n    };\n}\n// Utility function to get the appropriate Supabase client\nconst getSupabaseClient = (admin = false)=>{\n    // For admin operations (from API routes), use admin client if available\n    if (admin && supabaseAdminClient) {\n        console.log(\"Using Supabase admin client\");\n        return supabaseAdminClient;\n    }\n    // For normal operations, use the regular client if available\n    if (supabaseClient) {\n        console.log(\"Using Supabase anon client\");\n        return supabaseClient;\n    }\n    // If no client is available, log warning and return mock client\n    console.warn(\"No Supabase client available, using mock implementation\");\n    return createMockClient();\n};\n// Export default client for convenience\nconst supabase = getSupabaseClient();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (supabase);\n// Helper function to fetch a villa by ID\nasync function getVillaById(id) {\n    try {\n        const client = getSupabaseClient();\n        console.log(`Fetching villa with ID: ${id}`);\n        const { data, error } = await client.from(\"villas\").select(\"*\").eq(\"id\", id).single();\n        if (error) {\n            console.error(\"Error fetching villa:\", error);\n            return null;\n        }\n        return data;\n    } catch (error) {\n        console.error(\"Error fetching villa:\", error);\n        return null;\n    }\n}\n// Helper function to create a new booking with improved error handling\nasync function createBooking(bookingData, client = null) {\n    try {\n        // Use provided client or get the default one\n        const supabase = client || getSupabaseClient(\"undefined\" === \"undefined\");\n        console.log(\"Creating booking with client type:\", client ? \"provided client\" :  true ? \"server-side client\" : 0);\n        console.log(\"Submitting booking data to Supabase:\", bookingData);\n        // Begin by checking if we have a valid UUID for villa_id\n        let villaId = bookingData.villa_id;\n        // If villa_id is not a valid UUID, try to get the first villa from the database\n        if (!isValidUUID(villaId)) {\n            console.log(\"villa_id is not a valid UUID, attempting to find a valid villa\");\n            try {\n                const { data: villas, error } = await supabase.from(\"villas\").select(\"id\").limit(1);\n                if (error) {\n                    console.error(\"Error finding valid villa:\", error);\n                    throw new Error(`Failed to find a valid villa: ${error.message}`);\n                }\n                if (villas && villas.length > 0) {\n                    villaId = villas[0].id;\n                    console.log(\"Found valid villa ID:\", villaId);\n                } else {\n                    // If no villas exist, create a test villa\n                    console.log(\"No villas found, creating a test villa\");\n                    const { data: newVilla, error: villaError } = await supabase.from(\"villas\").insert([\n                        {\n                            name: \"Test Villa\",\n                            description: \"Test villa created during booking\",\n                            short_description: \"Test villa\",\n                            location: \"Test location\",\n                            price: bookingData.total_amount / 2,\n                            bedrooms: 3,\n                            bathrooms: 2,\n                            max_guests: bookingData.guests,\n                            images: [],\n                            amenities: []\n                        }\n                    ]).select();\n                    if (villaError) {\n                        console.error(\"Error creating test villa:\", villaError);\n                        throw new Error(`Failed to create test villa: ${villaError.message}`);\n                    }\n                    if (newVilla && newVilla.length > 0) {\n                        villaId = newVilla[0].id;\n                        console.log(\"Created test villa with ID:\", villaId);\n                    } else {\n                        throw new Error(\"Failed to create test villa\");\n                    }\n                }\n            } catch (err) {\n                console.error(\"Error during villa lookup:\", err);\n                // Fall back to using the original villa_id\n                console.log(\"Falling back to original villa_id:\", villaId);\n            }\n        }\n        // First, create a transaction record\n        console.log(\"Creating transaction record\");\n        const { data: transaction, error: transactionError } = await supabase.from(\"transactions\").insert([\n            {\n                payment_id: bookingData.payment_id,\n                amount: bookingData.total_amount,\n                status: \"completed\",\n                payment_method: \"credit_card\",\n                payment_details: {\n                    source: \"direct_booking\"\n                }\n            }\n        ]).select();\n        if (transactionError) {\n            console.error(\"Error creating transaction:\", transactionError);\n            throw transactionError;\n        }\n        console.log(\"Transaction created successfully:\", transaction);\n        // Check if bookings table has payment_id column\n        let hasPaymentIdColumn = true;\n        try {\n            // Try a test insert with payment_id to check if it exists\n            const testInsert = {\n                villa_id: villaId,\n                check_in: bookingData.check_in,\n                check_out: bookingData.check_out,\n                guests: bookingData.guests,\n                first_name: \"test\",\n                last_name: \"user\",\n                email: \"test@example.com\",\n                phone: \"1234567890\",\n                total_amount: 1,\n                status: \"cancelled\",\n                payment_id: \"test\"\n            };\n            const { error: testError } = await supabase.from(\"bookings\").insert([\n                testInsert\n            ]);\n            if (testError && testError.message.includes(\"payment_id\")) {\n                console.log(\"payment_id column does not exist in bookings table\");\n                hasPaymentIdColumn = false;\n            }\n            // Delete the test booking\n            await supabase.from(\"bookings\").delete().eq(\"email\", \"test@example.com\").eq(\"status\", \"cancelled\");\n        } catch (testError) {\n            console.log(\"Error testing payment_id column:\", testError);\n            // Assume it doesn't exist to be safe\n            hasPaymentIdColumn = false;\n        }\n        // Now create the booking with or without payment_id\n        console.log(\"Creating booking record\");\n        let bookingInsert = {\n            villa_id: villaId,\n            check_in: bookingData.check_in,\n            check_out: bookingData.check_out,\n            guests: bookingData.guests,\n            first_name: bookingData.first_name,\n            last_name: bookingData.last_name,\n            email: bookingData.email,\n            phone: bookingData.phone,\n            special_requests: bookingData.special_requests,\n            total_amount: bookingData.total_amount,\n            status: \"confirmed\"\n        };\n        // Only include payment_id if the column exists\n        if (hasPaymentIdColumn) {\n            bookingInsert.payment_id = bookingData.payment_id;\n        }\n        const { data: booking, error: bookingError } = await supabase.from(\"bookings\").insert([\n            bookingInsert\n        ]).select();\n        if (bookingError) {\n            console.error(\"Error creating booking:\", bookingError);\n            // If the error mentions payment_id, try again without it\n            if (hasPaymentIdColumn && bookingError.message.includes(\"payment_id\")) {\n                console.log(\"Retrying without payment_id\");\n                delete bookingInsert.payment_id;\n                const { data: retryBooking, error: retryError } = await supabase.from(\"bookings\").insert([\n                    bookingInsert\n                ]).select();\n                if (retryError) {\n                    console.error(\"Retry also failed:\", retryError);\n                    throw retryError;\n                }\n                console.log(\"Booking created successfully on retry:\", retryBooking);\n                return retryBooking ? retryBooking[0] : null;\n            }\n            throw bookingError;\n        }\n        console.log(\"Booking created successfully:\", booking);\n        // Update transaction with booking_id\n        if (booking && booking.length > 0 && transaction && transaction.length > 0) {\n            console.log(`Updating transaction ${transaction[0].id} with booking ID ${booking[0].id}`);\n            const { error: updateError } = await supabase.from(\"transactions\").update({\n                booking_id: booking[0].id\n            }).eq(\"id\", transaction[0].id);\n            if (updateError) {\n                console.warn(\"Warning: Could not update transaction with booking ID:\", updateError);\n            }\n        }\n        return booking ? booking[0] : null;\n    } catch (error) {\n        console.error(\"Error in createBooking:\", error);\n        throw error;\n    }\n}\n// Helper function to check if a string is a valid UUID\nfunction isValidUUID(str) {\n    if (!str) return false;\n    // Simple UUID validation regex\n    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n    return uuidRegex.test(str);\n}\n// Helper function to check villa availability\nasync function checkVillaAvailability(villaId, checkIn, checkOut) {\n    try {\n        // Get client and log action\n        const supabaseClient = getSupabaseClient();\n        console.log(`Checking availability for villa ${villaId} from ${checkIn} to ${checkOut}`);\n        // This is a simplified implementation that works with TypeScript\n        // Create a query first to workaround TypeScript issues\n        const query = supabaseClient.from(\"bookings\").select(\"*\");\n        // @ts-ignore - Ignore TypeScript errors for the next part\n        const { data, error } = await query// @ts-ignore\n        .eq(\"villa_id\", villaId)// @ts-ignore\n        .eq(\"status\", \"confirmed\");\n        if (error) {\n            console.error(\"Error checking availability:\", error);\n            return false;\n        }\n        // If there are no bookings, villa is available\n        if (!data || data.length === 0) {\n            return true;\n        }\n        // Convert dates to timestamps for comparison\n        const requestStart = new Date(checkIn).getTime();\n        const requestEnd = new Date(checkOut).getTime();\n        // Check for overlapping bookings\n        const hasConflict = data.some((booking)=>{\n            const bookingStart = new Date(booking.check_in).getTime();\n            const bookingEnd = new Date(booking.check_out).getTime();\n            // Check if date ranges overlap\n            return requestStart <= bookingEnd && requestEnd >= bookingStart;\n        });\n        // Return availability (true if no conflict)\n        return !hasConflict;\n    } catch (error) {\n        console.error(\"Error checking villa availability:\", error);\n        return false; // Assume unavailable on error\n    }\n}\n// Load mock data if needed\nconst loadMockData = async ()=>{\n    try {\n        // In a real app, you would fetch this from an API endpoint\n        // For now, we'll just use some hardcoded data\n        mockVillas = [\n            {\n                id: \"550e8400-e29b-41d4-a716-446655440000\",\n                name: \"Luxury Beachfront Villa\",\n                description: \"Experience the ultimate luxury getaway at our stunning beachfront villa. Nestled on the pristine shores of a private beach, this exquisite property offers breathtaking ocean views from every angle.\",\n                short_description: \"Stunning beachfront villa with private pool, direct beach access, and breathtaking ocean views.\",\n                location: \"Malibu, California\",\n                price: 1200.00,\n                bedrooms: 5,\n                bathrooms: 6,\n                max_guests: 12,\n                images: [\n                    \"/images/villa-exterior.jpg\",\n                    \"/images/villa-interior-1.jpg\",\n                    \"/images/villa-interior-2.jpg\",\n                    \"/images/villa-bedroom.jpg\",\n                    \"/images/villa-bathroom.jpg\",\n                    \"/images/villa-pool.jpg\",\n                    \"/images/villa-beach.jpg\",\n                    \"/images/villa-dining.jpg\"\n                ],\n                amenities: [\n                    \"Private Pool\",\n                    \"Direct Beach Access\",\n                    \"Ocean View\",\n                    \"Fully Equipped Kitchen\",\n                    \"Air Conditioning\",\n                    \"Free WiFi\",\n                    \"Smart TV\",\n                    \"Outdoor Dining Area\",\n                    \"BBQ Grill\",\n                    \"Parking\",\n                    \"Gym\",\n                    \"Home Theater\",\n                    \"Laundry Facilities\",\n                    \"24/7 Security\",\n                    \"Concierge Service\"\n                ],\n                created_at: new Date().toISOString()\n            }\n        ];\n        mockBookings = [];\n        console.log(\"Mock data loaded successfully\");\n    } catch (error) {\n        console.error(\"Error loading mock data:\", error);\n    }\n};\n// Load mock data on initialization if needed\nif (false) {}\n// Helper function to test Supabase connection\nasync function testSupabaseConnection() {\n    try {\n        console.log(\"Testing Supabase connection...\");\n        const client = getSupabaseClient();\n        // Try a simple query to check connection\n        const { data, error } = await client.from(\"villas\").select(\"id, name\").limit(1);\n        if (error) {\n            console.error(\"Supabase connection test failed:\", error);\n            return {\n                success: false,\n                error: error.message,\n                details: error,\n                clientType: client === supabaseClient ? \"anon\" : client === supabaseAdminClient ? \"admin\" : \"mock\"\n            };\n        }\n        console.log(\"Supabase connection successful:\", data);\n        return {\n            success: true,\n            data,\n            clientType: client === supabaseClient ? \"anon\" : client === supabaseAdminClient ? \"admin\" : \"mock\"\n        };\n    } catch (error) {\n        console.error(\"Error testing Supabase connection:\", error);\n        return {\n            success: false,\n            error: String(error),\n            clientType: \"unknown\"\n        };\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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UUFBUUMsR0FBRyxDQUFDLG1DQUFtQ2U7UUFDL0MsT0FBTztZQUNMa0csU0FBUztZQUNUbEc7WUFDQW9HLFlBQVluRSxXQUFXbkQsaUJBQWlCLFNBQVNtRCxXQUFXbEQsc0JBQXNCLFVBQVU7UUFDOUY7SUFDRixFQUFFLE9BQU9NLE9BQU87UUFDZEwsUUFBUUssS0FBSyxDQUFDLHNDQUFzQ0E7UUFDcEQsT0FBTztZQUNMNkcsU0FBUztZQUNUN0csT0FBT2dILE9BQU9oSDtZQUNkK0csWUFBWTtRQUNkO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpbGxhLWJvb2tpbmcvLi91dGlscy9zdXBhYmFzZS50cz83ZGUzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUNsaWVudCwgU3VwYWJhc2VDbGllbnQgfSBmcm9tICdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnO1xuXG4vLyBEZWZpbmUgdmlsbGEgYW5kIGJvb2tpbmcgdHlwZXNcbmV4cG9ydCB0eXBlIFZpbGxhID0ge1xuICBpZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gIHNob3J0X2Rlc2NyaXB0aW9uOiBzdHJpbmc7XG4gIGxvY2F0aW9uOiBzdHJpbmc7XG4gIHByaWNlOiBudW1iZXI7XG4gIGJlZHJvb21zOiBudW1iZXI7XG4gIGJhdGhyb29tczogbnVtYmVyO1xuICBtYXhfZ3Vlc3RzOiBudW1iZXI7XG4gIGltYWdlczogc3RyaW5nW107XG4gIGFtZW5pdGllczogc3RyaW5nW107XG4gIGNyZWF0ZWRfYXQ6IHN0cmluZztcbn07XG5cbmV4cG9ydCB0eXBlIEJvb2tpbmcgPSB7XG4gIGlkOiBzdHJpbmc7XG4gIGNoZWNrX2luOiBzdHJpbmc7XG4gIGNoZWNrX291dDogc3RyaW5nO1xuICBndWVzdHM6IG51bWJlcjtcbiAgZmlyc3RfbmFtZTogc3RyaW5nO1xuICBsYXN0X25hbWU6IHN0cmluZztcbiAgZW1haWw6IHN0cmluZztcbiAgcGhvbmU6IHN0cmluZztcbiAgc3BlY2lhbF9yZXF1ZXN0cz86IHN0cmluZztcbiAgdG90YWxfYW1vdW50OiBudW1iZXI7XG4gIHBheW1lbnRfaWQ6IHN0cmluZztcbiAgdmlsbGFfaWQ6IHN0cmluZztcbiAgc3RhdHVzOiAncGVuZGluZycgfCAnY29uZmlybWVkJyB8ICdjYW5jZWxsZWQnO1xuICBjcmVhdGVkX2F0OiBzdHJpbmc7XG59O1xuXG4vLyBNb2NrIGRhdGEgZm9yIGZhbGxiYWNrIHdoZW4gU3VwYWJhc2UgaXNuJ3QgYXZhaWxhYmxlXG5sZXQgbW9ja1ZpbGxhczogVmlsbGFbXSA9IFtdO1xubGV0IG1vY2tCb29raW5nczogQm9va2luZ1tdID0gW107XG5cbi8vIFN1cGFiYXNlIGNsaWVudCBpbml0aWFsaXphdGlvblxubGV0IHN1cGFiYXNlVXJsID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMO1xubGV0IHN1cGFiYXNlQW5vbktleSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZO1xubGV0IHN1cGFiYXNlU2VydmljZUtleSA9IHByb2Nlc3MuZW52LlNVUEFCQVNFX1NFUlZJQ0VfS0VZO1xubGV0IHN1cGFiYXNlQ2xpZW50OiBTdXBhYmFzZUNsaWVudCB8IG51bGwgPSBudWxsO1xubGV0IHN1cGFiYXNlQWRtaW5DbGllbnQ6IFN1cGFiYXNlQ2xpZW50IHwgbnVsbCA9IG51bGw7XG5cbi8vIExvZyBlbnZpcm9ubWVudCB2YXJpYWJsZXMgc3RhdHVzXG5jb25zb2xlLmxvZygnU3VwYWJhc2UgZW52aXJvbm1lbnQgdmFyaWFibGVzIHN0YXR1czonLCB7XG4gIHVybEV4aXN0czogISFzdXBhYmFzZVVybCxcbiAgYW5vbktleUV4aXN0czogISFzdXBhYmFzZUFub25LZXksXG4gIHNlcnZpY2VLZXlFeGlzdHM6ICEhc3VwYWJhc2VTZXJ2aWNlS2V5LFxufSk7XG5cbi8vIEF0dGVtcHQgdG8gaW5pdGlhbGl6ZSBTdXBhYmFzZSBjbGllbnQgd2l0aCBjcmVkZW50aWFsc1xuaWYgKHN1cGFiYXNlVXJsICYmIHN1cGFiYXNlQW5vbktleSkge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCdJbml0aWFsaXppbmcgU3VwYWJhc2UgY2xpZW50IHdpdGggYXZhaWxhYmxlIGNyZWRlbnRpYWxzJyk7XG4gICAgc3VwYWJhc2VDbGllbnQgPSBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSk7XG4gICAgY29uc29sZS5sb2coJ1N1cGFiYXNlIGNsaWVudCBpbml0aWFsaXplZCBzdWNjZXNzZnVsbHknKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gaW5pdGlhbGl6ZSBTdXBhYmFzZSBjbGllbnQ6JywgZXJyb3IpO1xuICB9XG59XG5cbi8vIEF0dGVtcHQgdG8gaW5pdGlhbGl6ZSBhZG1pbiBjbGllbnQgaW4gc2VydmVyLXNpZGUgY29kZVxuaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnICYmIHN1cGFiYXNlVXJsICYmIHN1cGFiYXNlU2VydmljZUtleSkge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCdJbml0aWFsaXppbmcgU3VwYWJhc2UgYWRtaW4gY2xpZW50Jyk7XG4gICAgc3VwYWJhc2VBZG1pbkNsaWVudCA9IGNyZWF0ZUNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VTZXJ2aWNlS2V5LCB7XG4gICAgICBhdXRoOiB7XG4gICAgICAgIGF1dG9SZWZyZXNoVG9rZW46IGZhbHNlLFxuICAgICAgICBwZXJzaXN0U2Vzc2lvbjogZmFsc2VcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zb2xlLmxvZygnU3VwYWJhc2UgYWRtaW4gY2xpZW50IGluaXRpYWxpemVkIHN1Y2Nlc3NmdWxseScpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBpbml0aWFsaXplIFN1cGFiYXNlIGFkbWluIGNsaWVudDonLCBlcnJvcik7XG4gIH1cbn1cblxuLy8gRnVuY3Rpb24gdG8gY3JlYXRlIGEgbW9jayBTdXBhYmFzZSBjbGllbnRcbmZ1bmN0aW9uIGNyZWF0ZU1vY2tDbGllbnQoKSB7XG4gIGNvbnNvbGUud2FybignQ3JlYXRpbmcgbW9jayBTdXBhYmFzZSBjbGllbnQnKTtcbiAgcmV0dXJuIHtcbiAgICBmcm9tOiAodGFibGU6IHN0cmluZykgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2VsZWN0OiAoY29sdW1uczogc3RyaW5nID0gJyonKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coYE1vY2sgU0VMRUNUICR7Y29sdW1uc30gRlJPTSAke3RhYmxlfWApO1xuICAgICAgICAgIGNvbnN0IG1vY2tSZXN1bHQgPSB7XG4gICAgICAgICAgICBkYXRhOiB0YWJsZSA9PT0gJ3ZpbGxhcycgPyBtb2NrVmlsbGFzIDogbW9ja0Jvb2tpbmdzLFxuICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEFkZCBtZXRob2RzIHRoYXQgYXJlIHVzZWQgaW4geW91ciBjb2RlYmFzZVxuICAgICAgICAgICAgZXE6IGZ1bmN0aW9uKGNvbHVtbjogc3RyaW5nLCB2YWx1ZTogYW55KSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBNb2NrIFdIRVJFICR7Y29sdW1ufSA9ICR7dmFsdWV9YCk7XG4gICAgICAgICAgICAgIGxldCBmaWx0ZXJlZDogKFZpbGxhIHwgQm9va2luZylbXSA9IFtdO1xuICAgICAgICAgICAgICBpZiAodGFibGUgPT09ICd2aWxsYXMnKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyZWQgPSBtb2NrVmlsbGFzLmZpbHRlcigoaXRlbTogVmlsbGEpID0+IGl0ZW1bY29sdW1uIGFzIGtleW9mIFZpbGxhXSA9PT0gdmFsdWUpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhYmxlID09PSAnYm9va2luZ3MnKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyZWQgPSBtb2NrQm9va2luZ3MuZmlsdGVyKChpdGVtOiBCb29raW5nKSA9PiBpdGVtW2NvbHVtbiBhcyBrZXlvZiBCb29raW5nXSA9PT0gdmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGE6IGZpbHRlcmVkLFxuICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgIGxpbWl0OiBmdW5jdGlvbihuOiBudW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBNb2NrIExJTUlUICR7bn1gKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGZpbHRlcmVkLnNsaWNlKDAsIG4pLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgc2luZ2xlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZmlsdGVyZWQubGVuZ3RoID4gMCA/IGZpbHRlcmVkWzBdIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBmaWx0ZXJlZC5sZW5ndGggPiAwID8gbnVsbCA6IHsgbWVzc2FnZTogJ05vdCBmb3VuZCcgfVxuICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzaW5nbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZmlsdGVyZWQubGVuZ3RoID4gMCA/IGZpbHRlcmVkWzBdIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGZpbHRlcmVkLmxlbmd0aCA+IDAgPyBudWxsIDogeyBtZXNzYWdlOiAnTm90IGZvdW5kJyB9XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGxpbWl0OiBmdW5jdGlvbihuOiBudW1iZXIpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYE1vY2sgTElNSVQgJHtufWApO1xuICAgICAgICAgICAgICBjb25zdCBsaW1pdGVkRGF0YSA9ICh0YWJsZSA9PT0gJ3ZpbGxhcycgPyBtb2NrVmlsbGFzIDogbW9ja0Jvb2tpbmdzKS5zbGljZSgwLCBuKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBsaW1pdGVkRGF0YSxcbiAgICAgICAgICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIG1vY2tSZXN1bHQ7XG4gICAgICAgIH0sXG4gICAgICAgIGluc2VydDogKGRhdGE6IGFueSkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBNb2NrIElOU0VSVCBJTlRPICR7dGFibGV9YCwgZGF0YSk7XG4gICAgICAgICAgY29uc3QgbmV3SXRlbSA9IHtcbiAgICAgICAgICAgIGlkOiBgbW9jay0ke0RhdGUubm93KCl9YCxcbiAgICAgICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIC4uLmRhdGFcbiAgICAgICAgICB9O1xuICAgICAgICAgIFxuICAgICAgICAgIGlmICh0YWJsZSA9PT0gJ3ZpbGxhcycpIHtcbiAgICAgICAgICAgIG1vY2tWaWxsYXMucHVzaChuZXdJdGVtIGFzIFZpbGxhKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRhYmxlID09PSAnYm9va2luZ3MnKSB7XG4gICAgICAgICAgICBtb2NrQm9va2luZ3MucHVzaChuZXdJdGVtIGFzIEJvb2tpbmcpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGFibGUgPT09ICd0cmFuc2FjdGlvbnMnKSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgdHJhbnNhY3Rpb25zIG1vY2sgdGFibGVcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdNb2NrIHRyYW5zYWN0aW9uIGNyZWF0ZWQ6JywgbmV3SXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiBbbmV3SXRlbV0sXG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgIHNlbGVjdDogKCkgPT4gKHsgZGF0YTogW25ld0l0ZW1dLCBlcnJvcjogbnVsbCB9KVxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZTogKGRhdGE6IGFueSkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBNb2NrIFVQREFURSAke3RhYmxlfWAsIGRhdGEpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcTogZnVuY3Rpb24oY29sdW1uOiBzdHJpbmcsIHZhbHVlOiBhbnkpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYE1vY2sgV0hFUkUgJHtjb2x1bW59ID0gJHt2YWx1ZX1gKTtcbiAgICAgICAgICAgICAgaWYgKHRhYmxlID09PSAndmlsbGFzJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gbW9ja1ZpbGxhcy5maW5kSW5kZXgoKGl0ZW06IFZpbGxhKSA9PiBpdGVtW2NvbHVtbiBhcyBrZXlvZiBWaWxsYV0gPT09IHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICBtb2NrVmlsbGFzW2luZGV4XSA9IHsgLi4ubW9ja1ZpbGxhc1tpbmRleF0sIC4uLmRhdGEgfTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG1vY2tWaWxsYXNbaW5kZXhdLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0YWJsZSA9PT0gJ2Jvb2tpbmdzJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gbW9ja0Jvb2tpbmdzLmZpbmRJbmRleCgoaXRlbTogQm9va2luZykgPT4gaXRlbVtjb2x1bW4gYXMga2V5b2YgQm9va2luZ10gPT09IHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICBtb2NrQm9va2luZ3NbaW5kZXhdID0geyAuLi5tb2NrQm9va2luZ3NbaW5kZXhdLCAuLi5kYXRhIH07XG4gICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBtb2NrQm9va2luZ3NbaW5kZXhdLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IHsgbWVzc2FnZTogJ0l0ZW0gbm90IGZvdW5kJyB9IH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWF0Y2g6ICh7IGlkIH06IHsgaWQ6IHN0cmluZyB9KSA9PiB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBNb2NrIFdIRVJFIGlkID0gJHtpZH1gKTtcbiAgICAgICAgICAgICAgaWYgKHRhYmxlID09PSAndmlsbGFzJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gbW9ja1ZpbGxhcy5maW5kSW5kZXgoKGl0ZW06IFZpbGxhKSA9PiBpdGVtLmlkID09PSBpZCk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgbW9ja1ZpbGxhc1tpbmRleF0gPSB7IC4uLm1vY2tWaWxsYXNbaW5kZXhdLCAuLi5kYXRhIH07XG4gICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBtb2NrVmlsbGFzW2luZGV4XSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodGFibGUgPT09ICdib29raW5ncycpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IG1vY2tCb29raW5ncy5maW5kSW5kZXgoKGl0ZW06IEJvb2tpbmcpID0+IGl0ZW0uaWQgPT09IGlkKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICBtb2NrQm9va2luZ3NbaW5kZXhdID0geyAuLi5tb2NrQm9va2luZ3NbaW5kZXhdLCAuLi5kYXRhIH07XG4gICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBtb2NrQm9va2luZ3NbaW5kZXhdLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IHsgbWVzc2FnZTogJ0l0ZW0gbm90IGZvdW5kJyB9IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coYE1vY2sgREVMRVRFIEZST00gJHt0YWJsZX1gKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWF0Y2g6ICh7IGlkIH06IHsgaWQ6IHN0cmluZyB9KSA9PiB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBNb2NrIFdIRVJFIGlkID0gJHtpZH1gKTtcbiAgICAgICAgICAgICAgaWYgKHRhYmxlID09PSAndmlsbGFzJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gbW9ja1ZpbGxhcy5maW5kSW5kZXgoKGl0ZW06IFZpbGxhKSA9PiBpdGVtLmlkID09PSBpZCk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgZGVsZXRlZCA9IG1vY2tWaWxsYXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgbW9ja1ZpbGxhcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogZGVsZXRlZCwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodGFibGUgPT09ICdib29raW5ncycpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IG1vY2tCb29raW5ncy5maW5kSW5kZXgoKGl0ZW06IEJvb2tpbmcpID0+IGl0ZW0uaWQgPT09IGlkKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBkZWxldGVkID0gbW9ja0Jvb2tpbmdzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgIG1vY2tCb29raW5ncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogZGVsZXRlZCwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiB7IG1lc3NhZ2U6ICdJdGVtIG5vdCBmb3VuZCcgfSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuXG4vLyBVdGlsaXR5IGZ1bmN0aW9uIHRvIGdldCB0aGUgYXBwcm9wcmlhdGUgU3VwYWJhc2UgY2xpZW50XG5leHBvcnQgY29uc3QgZ2V0U3VwYWJhc2VDbGllbnQgPSAoYWRtaW4gPSBmYWxzZSkgPT4ge1xuICAvLyBGb3IgYWRtaW4gb3BlcmF0aW9ucyAoZnJvbSBBUEkgcm91dGVzKSwgdXNlIGFkbWluIGNsaWVudCBpZiBhdmFpbGFibGVcbiAgaWYgKGFkbWluICYmIHN1cGFiYXNlQWRtaW5DbGllbnQpIHtcbiAgICBjb25zb2xlLmxvZygnVXNpbmcgU3VwYWJhc2UgYWRtaW4gY2xpZW50Jyk7XG4gICAgcmV0dXJuIHN1cGFiYXNlQWRtaW5DbGllbnQ7XG4gIH1cbiAgXG4gIC8vIEZvciBub3JtYWwgb3BlcmF0aW9ucywgdXNlIHRoZSByZWd1bGFyIGNsaWVudCBpZiBhdmFpbGFibGVcbiAgaWYgKHN1cGFiYXNlQ2xpZW50KSB7XG4gICAgY29uc29sZS5sb2coJ1VzaW5nIFN1cGFiYXNlIGFub24gY2xpZW50Jyk7XG4gICAgcmV0dXJuIHN1cGFiYXNlQ2xpZW50O1xuICB9XG4gIFxuICAvLyBJZiBubyBjbGllbnQgaXMgYXZhaWxhYmxlLCBsb2cgd2FybmluZyBhbmQgcmV0dXJuIG1vY2sgY2xpZW50XG4gIGNvbnNvbGUud2FybignTm8gU3VwYWJhc2UgY2xpZW50IGF2YWlsYWJsZSwgdXNpbmcgbW9jayBpbXBsZW1lbnRhdGlvbicpO1xuICByZXR1cm4gY3JlYXRlTW9ja0NsaWVudCgpO1xufTtcblxuLy8gRXhwb3J0IGRlZmF1bHQgY2xpZW50IGZvciBjb252ZW5pZW5jZVxuY29uc3Qgc3VwYWJhc2UgPSBnZXRTdXBhYmFzZUNsaWVudCgpO1xuZXhwb3J0IGRlZmF1bHQgc3VwYWJhc2U7XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBmZXRjaCBhIHZpbGxhIGJ5IElEXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VmlsbGFCeUlkKGlkOiBzdHJpbmcpOiBQcm9taXNlPFZpbGxhIHwgbnVsbD4ge1xuICB0cnkge1xuICAgIGNvbnN0IGNsaWVudCA9IGdldFN1cGFiYXNlQ2xpZW50KCk7XG4gICAgY29uc29sZS5sb2coYEZldGNoaW5nIHZpbGxhIHdpdGggSUQ6ICR7aWR9YCk7XG4gICAgXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgY2xpZW50XG4gICAgICAuZnJvbSgndmlsbGFzJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCdpZCcsIGlkKVxuICAgICAgLnNpbmdsZSgpO1xuICAgICAgXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyB2aWxsYTonLCBlcnJvcik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGRhdGEgYXMgVmlsbGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgdmlsbGE6JywgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgYSBuZXcgYm9va2luZyB3aXRoIGltcHJvdmVkIGVycm9yIGhhbmRsaW5nXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlQm9va2luZyhcbiAgYm9va2luZ0RhdGE6IE9taXQ8Qm9va2luZywgJ2lkJyB8ICdjcmVhdGVkX2F0Jz4sXG4gIGNsaWVudDogYW55ID0gbnVsbFxuKSB7XG4gIHRyeSB7XG4gICAgLy8gVXNlIHByb3ZpZGVkIGNsaWVudCBvciBnZXQgdGhlIGRlZmF1bHQgb25lXG4gICAgY29uc3Qgc3VwYWJhc2UgPSBjbGllbnQgfHwgZ2V0U3VwYWJhc2VDbGllbnQodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKCdDcmVhdGluZyBib29raW5nIHdpdGggY2xpZW50IHR5cGU6JywgXG4gICAgICBjbGllbnQgPyAncHJvdmlkZWQgY2xpZW50JyA6IFxuICAgICAgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyAnc2VydmVyLXNpZGUgY2xpZW50JyA6ICdicm93c2VyIGNsaWVudCcpO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKCdTdWJtaXR0aW5nIGJvb2tpbmcgZGF0YSB0byBTdXBhYmFzZTonLCBib29raW5nRGF0YSk7XG4gICAgXG4gICAgLy8gQmVnaW4gYnkgY2hlY2tpbmcgaWYgd2UgaGF2ZSBhIHZhbGlkIFVVSUQgZm9yIHZpbGxhX2lkXG4gICAgbGV0IHZpbGxhSWQgPSBib29raW5nRGF0YS52aWxsYV9pZDtcbiAgICBcbiAgICAvLyBJZiB2aWxsYV9pZCBpcyBub3QgYSB2YWxpZCBVVUlELCB0cnkgdG8gZ2V0IHRoZSBmaXJzdCB2aWxsYSBmcm9tIHRoZSBkYXRhYmFzZVxuICAgIGlmICghaXNWYWxpZFVVSUQodmlsbGFJZCkpIHtcbiAgICAgIGNvbnNvbGUubG9nKCd2aWxsYV9pZCBpcyBub3QgYSB2YWxpZCBVVUlELCBhdHRlbXB0aW5nIHRvIGZpbmQgYSB2YWxpZCB2aWxsYScpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBkYXRhOiB2aWxsYXMsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCd2aWxsYXMnKVxuICAgICAgICAgIC5zZWxlY3QoJ2lkJylcbiAgICAgICAgICAubGltaXQoMSk7XG4gICAgICAgICAgXG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZpbmRpbmcgdmFsaWQgdmlsbGE6JywgZXJyb3IpO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZpbmQgYSB2YWxpZCB2aWxsYTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAodmlsbGFzICYmIHZpbGxhcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmlsbGFJZCA9IHZpbGxhc1swXS5pZDtcbiAgICAgICAgICBjb25zb2xlLmxvZygnRm91bmQgdmFsaWQgdmlsbGEgSUQ6JywgdmlsbGFJZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSWYgbm8gdmlsbGFzIGV4aXN0LCBjcmVhdGUgYSB0ZXN0IHZpbGxhXG4gICAgICAgICAgY29uc29sZS5sb2coJ05vIHZpbGxhcyBmb3VuZCwgY3JlYXRpbmcgYSB0ZXN0IHZpbGxhJyk7XG4gICAgICAgICAgY29uc3QgeyBkYXRhOiBuZXdWaWxsYSwgZXJyb3I6IHZpbGxhRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAuZnJvbSgndmlsbGFzJylcbiAgICAgICAgICAgIC5pbnNlcnQoW3tcbiAgICAgICAgICAgICAgbmFtZTogJ1Rlc3QgVmlsbGEnLFxuICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogJ1Rlc3QgdmlsbGEgY3JlYXRlZCBkdXJpbmcgYm9va2luZycsXG4gICAgICAgICAgICAgIHNob3J0X2Rlc2NyaXB0aW9uOiAnVGVzdCB2aWxsYScsXG4gICAgICAgICAgICAgIGxvY2F0aW9uOiAnVGVzdCBsb2NhdGlvbicsXG4gICAgICAgICAgICAgIHByaWNlOiBib29raW5nRGF0YS50b3RhbF9hbW91bnQgLyAyLFxuICAgICAgICAgICAgICBiZWRyb29tczogMyxcbiAgICAgICAgICAgICAgYmF0aHJvb21zOiAyLFxuICAgICAgICAgICAgICBtYXhfZ3Vlc3RzOiBib29raW5nRGF0YS5ndWVzdHMsXG4gICAgICAgICAgICAgIGltYWdlczogW10sXG4gICAgICAgICAgICAgIGFtZW5pdGllczogW11cbiAgICAgICAgICAgIH1dKVxuICAgICAgICAgICAgLnNlbGVjdCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgaWYgKHZpbGxhRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIHRlc3QgdmlsbGE6JywgdmlsbGFFcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgdGVzdCB2aWxsYTogJHt2aWxsYUVycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGlmIChuZXdWaWxsYSAmJiBuZXdWaWxsYS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2aWxsYUlkID0gbmV3VmlsbGFbMF0uaWQ7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnQ3JlYXRlZCB0ZXN0IHZpbGxhIHdpdGggSUQ6JywgdmlsbGFJZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGNyZWF0ZSB0ZXN0IHZpbGxhJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZHVyaW5nIHZpbGxhIGxvb2t1cDonLCBlcnIpO1xuICAgICAgICAvLyBGYWxsIGJhY2sgdG8gdXNpbmcgdGhlIG9yaWdpbmFsIHZpbGxhX2lkXG4gICAgICAgIGNvbnNvbGUubG9nKCdGYWxsaW5nIGJhY2sgdG8gb3JpZ2luYWwgdmlsbGFfaWQ6JywgdmlsbGFJZCk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIEZpcnN0LCBjcmVhdGUgYSB0cmFuc2FjdGlvbiByZWNvcmRcbiAgICBjb25zb2xlLmxvZygnQ3JlYXRpbmcgdHJhbnNhY3Rpb24gcmVjb3JkJyk7XG4gICAgY29uc3QgeyBkYXRhOiB0cmFuc2FjdGlvbiwgZXJyb3I6IHRyYW5zYWN0aW9uRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgndHJhbnNhY3Rpb25zJylcbiAgICAgIC5pbnNlcnQoW1xuICAgICAgICB7XG4gICAgICAgICAgcGF5bWVudF9pZDogYm9va2luZ0RhdGEucGF5bWVudF9pZCxcbiAgICAgICAgICBhbW91bnQ6IGJvb2tpbmdEYXRhLnRvdGFsX2Ftb3VudCxcbiAgICAgICAgICBzdGF0dXM6ICdjb21wbGV0ZWQnLFxuICAgICAgICAgIHBheW1lbnRfbWV0aG9kOiAnY3JlZGl0X2NhcmQnLCAvLyBEZWZhdWx0IHZhbHVlXG4gICAgICAgICAgcGF5bWVudF9kZXRhaWxzOiB7IHNvdXJjZTogJ2RpcmVjdF9ib29raW5nJyB9XG4gICAgICAgIH1cbiAgICAgIF0pXG4gICAgICAuc2VsZWN0KCk7XG4gICAgICBcbiAgICBpZiAodHJhbnNhY3Rpb25FcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgdHJhbnNhY3Rpb246JywgdHJhbnNhY3Rpb25FcnJvcik7XG4gICAgICB0aHJvdyB0cmFuc2FjdGlvbkVycm9yO1xuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZygnVHJhbnNhY3Rpb24gY3JlYXRlZCBzdWNjZXNzZnVsbHk6JywgdHJhbnNhY3Rpb24pO1xuICAgIFxuICAgIC8vIENoZWNrIGlmIGJvb2tpbmdzIHRhYmxlIGhhcyBwYXltZW50X2lkIGNvbHVtblxuICAgIGxldCBoYXNQYXltZW50SWRDb2x1bW4gPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAvLyBUcnkgYSB0ZXN0IGluc2VydCB3aXRoIHBheW1lbnRfaWQgdG8gY2hlY2sgaWYgaXQgZXhpc3RzXG4gICAgICBjb25zdCB0ZXN0SW5zZXJ0ID0ge1xuICAgICAgICB2aWxsYV9pZDogdmlsbGFJZCxcbiAgICAgICAgY2hlY2tfaW46IGJvb2tpbmdEYXRhLmNoZWNrX2luLFxuICAgICAgICBjaGVja19vdXQ6IGJvb2tpbmdEYXRhLmNoZWNrX291dCxcbiAgICAgICAgZ3Vlc3RzOiBib29raW5nRGF0YS5ndWVzdHMsXG4gICAgICAgIGZpcnN0X25hbWU6ICd0ZXN0JyxcbiAgICAgICAgbGFzdF9uYW1lOiAndXNlcicsXG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIHBob25lOiAnMTIzNDU2Nzg5MCcsXG4gICAgICAgIHRvdGFsX2Ftb3VudDogMSxcbiAgICAgICAgc3RhdHVzOiAnY2FuY2VsbGVkJyxcbiAgICAgICAgcGF5bWVudF9pZDogJ3Rlc3QnXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCB7IGVycm9yOiB0ZXN0RXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdib29raW5ncycpXG4gICAgICAgIC5pbnNlcnQoW3Rlc3RJbnNlcnRdKTtcbiAgICAgICAgXG4gICAgICBpZiAodGVzdEVycm9yICYmIHRlc3RFcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdwYXltZW50X2lkJykpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ3BheW1lbnRfaWQgY29sdW1uIGRvZXMgbm90IGV4aXN0IGluIGJvb2tpbmdzIHRhYmxlJyk7XG4gICAgICAgIGhhc1BheW1lbnRJZENvbHVtbiA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBEZWxldGUgdGhlIHRlc3QgYm9va2luZ1xuICAgICAgYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2Jvb2tpbmdzJylcbiAgICAgICAgLmRlbGV0ZSgpXG4gICAgICAgIC5lcSgnZW1haWwnLCAndGVzdEBleGFtcGxlLmNvbScpXG4gICAgICAgIC5lcSgnc3RhdHVzJywgJ2NhbmNlbGxlZCcpO1xuICAgIH0gY2F0Y2ggKHRlc3RFcnJvcikge1xuICAgICAgY29uc29sZS5sb2coJ0Vycm9yIHRlc3RpbmcgcGF5bWVudF9pZCBjb2x1bW46JywgdGVzdEVycm9yKTtcbiAgICAgIC8vIEFzc3VtZSBpdCBkb2Vzbid0IGV4aXN0IHRvIGJlIHNhZmVcbiAgICAgIGhhc1BheW1lbnRJZENvbHVtbiA9IGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICAvLyBOb3cgY3JlYXRlIHRoZSBib29raW5nIHdpdGggb3Igd2l0aG91dCBwYXltZW50X2lkXG4gICAgY29uc29sZS5sb2coJ0NyZWF0aW5nIGJvb2tpbmcgcmVjb3JkJyk7XG4gICAgbGV0IGJvb2tpbmdJbnNlcnQ6IGFueSA9IHtcbiAgICAgIHZpbGxhX2lkOiB2aWxsYUlkLFxuICAgICAgY2hlY2tfaW46IGJvb2tpbmdEYXRhLmNoZWNrX2luLFxuICAgICAgY2hlY2tfb3V0OiBib29raW5nRGF0YS5jaGVja19vdXQsXG4gICAgICBndWVzdHM6IGJvb2tpbmdEYXRhLmd1ZXN0cyxcbiAgICAgIGZpcnN0X25hbWU6IGJvb2tpbmdEYXRhLmZpcnN0X25hbWUsXG4gICAgICBsYXN0X25hbWU6IGJvb2tpbmdEYXRhLmxhc3RfbmFtZSxcbiAgICAgIGVtYWlsOiBib29raW5nRGF0YS5lbWFpbCxcbiAgICAgIHBob25lOiBib29raW5nRGF0YS5waG9uZSxcbiAgICAgIHNwZWNpYWxfcmVxdWVzdHM6IGJvb2tpbmdEYXRhLnNwZWNpYWxfcmVxdWVzdHMsXG4gICAgICB0b3RhbF9hbW91bnQ6IGJvb2tpbmdEYXRhLnRvdGFsX2Ftb3VudCxcbiAgICAgIHN0YXR1czogJ2NvbmZpcm1lZCdcbiAgICB9O1xuICAgIFxuICAgIC8vIE9ubHkgaW5jbHVkZSBwYXltZW50X2lkIGlmIHRoZSBjb2x1bW4gZXhpc3RzXG4gICAgaWYgKGhhc1BheW1lbnRJZENvbHVtbikge1xuICAgICAgYm9va2luZ0luc2VydC5wYXltZW50X2lkID0gYm9va2luZ0RhdGEucGF5bWVudF9pZDtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgeyBkYXRhOiBib29raW5nLCBlcnJvcjogYm9va2luZ0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2Jvb2tpbmdzJylcbiAgICAgIC5pbnNlcnQoW2Jvb2tpbmdJbnNlcnRdKVxuICAgICAgLnNlbGVjdCgpO1xuICAgICAgXG4gICAgaWYgKGJvb2tpbmdFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgYm9va2luZzonLCBib29raW5nRXJyb3IpO1xuICAgICAgXG4gICAgICAvLyBJZiB0aGUgZXJyb3IgbWVudGlvbnMgcGF5bWVudF9pZCwgdHJ5IGFnYWluIHdpdGhvdXQgaXRcbiAgICAgIGlmIChoYXNQYXltZW50SWRDb2x1bW4gJiYgYm9va2luZ0Vycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ3BheW1lbnRfaWQnKSkge1xuICAgICAgICBjb25zb2xlLmxvZygnUmV0cnlpbmcgd2l0aG91dCBwYXltZW50X2lkJyk7XG4gICAgICAgIGRlbGV0ZSBib29raW5nSW5zZXJ0LnBheW1lbnRfaWQ7XG4gICAgICAgIFxuICAgICAgICBjb25zdCB7IGRhdGE6IHJldHJ5Qm9va2luZywgZXJyb3I6IHJldHJ5RXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ2Jvb2tpbmdzJylcbiAgICAgICAgICAuaW5zZXJ0KFtib29raW5nSW5zZXJ0XSlcbiAgICAgICAgICAuc2VsZWN0KCk7XG4gICAgICAgICAgXG4gICAgICAgIGlmIChyZXRyeUVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignUmV0cnkgYWxzbyBmYWlsZWQ6JywgcmV0cnlFcnJvcik7XG4gICAgICAgICAgdGhyb3cgcmV0cnlFcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coJ0Jvb2tpbmcgY3JlYXRlZCBzdWNjZXNzZnVsbHkgb24gcmV0cnk6JywgcmV0cnlCb29raW5nKTtcbiAgICAgICAgcmV0dXJuIHJldHJ5Qm9va2luZyA/IHJldHJ5Qm9va2luZ1swXSA6IG51bGw7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHRocm93IGJvb2tpbmdFcnJvcjtcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coJ0Jvb2tpbmcgY3JlYXRlZCBzdWNjZXNzZnVsbHk6JywgYm9va2luZyk7XG4gICAgXG4gICAgLy8gVXBkYXRlIHRyYW5zYWN0aW9uIHdpdGggYm9va2luZ19pZFxuICAgIGlmIChib29raW5nICYmIGJvb2tpbmcubGVuZ3RoID4gMCAmJiB0cmFuc2FjdGlvbiAmJiB0cmFuc2FjdGlvbi5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zb2xlLmxvZyhgVXBkYXRpbmcgdHJhbnNhY3Rpb24gJHt0cmFuc2FjdGlvblswXS5pZH0gd2l0aCBib29raW5nIElEICR7Ym9va2luZ1swXS5pZH1gKTtcbiAgICAgIGNvbnN0IHsgZXJyb3I6IHVwZGF0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgndHJhbnNhY3Rpb25zJylcbiAgICAgICAgLnVwZGF0ZSh7IGJvb2tpbmdfaWQ6IGJvb2tpbmdbMF0uaWQgfSlcbiAgICAgICAgLmVxKCdpZCcsIHRyYW5zYWN0aW9uWzBdLmlkKTtcbiAgICAgICAgXG4gICAgICBpZiAodXBkYXRlRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdXYXJuaW5nOiBDb3VsZCBub3QgdXBkYXRlIHRyYW5zYWN0aW9uIHdpdGggYm9va2luZyBJRDonLCB1cGRhdGVFcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBib29raW5nID8gYm9va2luZ1swXSA6IG51bGw7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gY3JlYXRlQm9va2luZzonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNoZWNrIGlmIGEgc3RyaW5nIGlzIGEgdmFsaWQgVVVJRFxuZnVuY3Rpb24gaXNWYWxpZFVVSUQoc3RyOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgaWYgKCFzdHIpIHJldHVybiBmYWxzZTtcbiAgXG4gIC8vIFNpbXBsZSBVVUlEIHZhbGlkYXRpb24gcmVnZXhcbiAgY29uc3QgdXVpZFJlZ2V4ID0gL15bMC05YS1mXXs4fS1bMC05YS1mXXs0fS1bMS01XVswLTlhLWZdezN9LVs4OWFiXVswLTlhLWZdezN9LVswLTlhLWZdezEyfSQvaTtcbiAgcmV0dXJuIHV1aWRSZWdleC50ZXN0KHN0cik7XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBjaGVjayB2aWxsYSBhdmFpbGFiaWxpdHlcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjaGVja1ZpbGxhQXZhaWxhYmlsaXR5KFxuICB2aWxsYUlkOiBzdHJpbmcsXG4gIGNoZWNrSW46IHN0cmluZyxcbiAgY2hlY2tPdXQ6IHN0cmluZ1xuKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIHRyeSB7XG4gICAgLy8gR2V0IGNsaWVudCBhbmQgbG9nIGFjdGlvblxuICAgIGNvbnN0IHN1cGFiYXNlQ2xpZW50ID0gZ2V0U3VwYWJhc2VDbGllbnQoKTtcbiAgICBjb25zb2xlLmxvZyhgQ2hlY2tpbmcgYXZhaWxhYmlsaXR5IGZvciB2aWxsYSAke3ZpbGxhSWR9IGZyb20gJHtjaGVja0lufSB0byAke2NoZWNrT3V0fWApO1xuICAgIFxuICAgIC8vIFRoaXMgaXMgYSBzaW1wbGlmaWVkIGltcGxlbWVudGF0aW9uIHRoYXQgd29ya3Mgd2l0aCBUeXBlU2NyaXB0XG4gICAgLy8gQ3JlYXRlIGEgcXVlcnkgZmlyc3QgdG8gd29ya2Fyb3VuZCBUeXBlU2NyaXB0IGlzc3Vlc1xuICAgIGNvbnN0IHF1ZXJ5ID0gc3VwYWJhc2VDbGllbnRcbiAgICAgIC5mcm9tKCdib29raW5ncycpXG4gICAgICAuc2VsZWN0KCcqJyk7XG4gICAgICBcbiAgICAvLyBAdHMtaWdub3JlIC0gSWdub3JlIFR5cGVTY3JpcHQgZXJyb3JzIGZvciB0aGUgbmV4dCBwYXJ0XG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgcXVlcnlcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIC5lcSgndmlsbGFfaWQnLCB2aWxsYUlkKVxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgLmVxKCdzdGF0dXMnLCAnY29uZmlybWVkJyk7XG4gICAgXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBhdmFpbGFiaWxpdHk6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICAvLyBJZiB0aGVyZSBhcmUgbm8gYm9va2luZ3MsIHZpbGxhIGlzIGF2YWlsYWJsZVxuICAgIGlmICghZGF0YSB8fCBkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIC8vIENvbnZlcnQgZGF0ZXMgdG8gdGltZXN0YW1wcyBmb3IgY29tcGFyaXNvblxuICAgIGNvbnN0IHJlcXVlc3RTdGFydCA9IG5ldyBEYXRlKGNoZWNrSW4pLmdldFRpbWUoKTtcbiAgICBjb25zdCByZXF1ZXN0RW5kID0gbmV3IERhdGUoY2hlY2tPdXQpLmdldFRpbWUoKTtcbiAgICBcbiAgICAvLyBDaGVjayBmb3Igb3ZlcmxhcHBpbmcgYm9va2luZ3NcbiAgICBjb25zdCBoYXNDb25mbGljdCA9IGRhdGEuc29tZSgoYm9va2luZzogYW55KSA9PiB7XG4gICAgICBjb25zdCBib29raW5nU3RhcnQgPSBuZXcgRGF0ZShib29raW5nLmNoZWNrX2luKS5nZXRUaW1lKCk7XG4gICAgICBjb25zdCBib29raW5nRW5kID0gbmV3IERhdGUoYm9va2luZy5jaGVja19vdXQpLmdldFRpbWUoKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgZGF0ZSByYW5nZXMgb3ZlcmxhcFxuICAgICAgcmV0dXJuIChyZXF1ZXN0U3RhcnQgPD0gYm9va2luZ0VuZCAmJiByZXF1ZXN0RW5kID49IGJvb2tpbmdTdGFydCk7XG4gICAgfSk7XG4gICAgXG4gICAgLy8gUmV0dXJuIGF2YWlsYWJpbGl0eSAodHJ1ZSBpZiBubyBjb25mbGljdClcbiAgICByZXR1cm4gIWhhc0NvbmZsaWN0O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNoZWNraW5nIHZpbGxhIGF2YWlsYWJpbGl0eTonLCBlcnJvcik7XG4gICAgcmV0dXJuIGZhbHNlOyAvLyBBc3N1bWUgdW5hdmFpbGFibGUgb24gZXJyb3JcbiAgfVxufVxuXG4vLyBMb2FkIG1vY2sgZGF0YSBpZiBuZWVkZWRcbmV4cG9ydCBjb25zdCBsb2FkTW9ja0RhdGEgPSBhc3luYyAoKSA9PiB7XG4gIHRyeSB7XG4gICAgLy8gSW4gYSByZWFsIGFwcCwgeW91IHdvdWxkIGZldGNoIHRoaXMgZnJvbSBhbiBBUEkgZW5kcG9pbnRcbiAgICAvLyBGb3Igbm93LCB3ZSdsbCBqdXN0IHVzZSBzb21lIGhhcmRjb2RlZCBkYXRhXG4gICAgbW9ja1ZpbGxhcyA9IFtcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwiNTUwZTg0MDAtZTI5Yi00MWQ0LWE3MTYtNDQ2NjU1NDQwMDAwXCIsXG4gICAgICAgIG5hbWU6IFwiTHV4dXJ5IEJlYWNoZnJvbnQgVmlsbGFcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiRXhwZXJpZW5jZSB0aGUgdWx0aW1hdGUgbHV4dXJ5IGdldGF3YXkgYXQgb3VyIHN0dW5uaW5nIGJlYWNoZnJvbnQgdmlsbGEuIE5lc3RsZWQgb24gdGhlIHByaXN0aW5lIHNob3JlcyBvZiBhIHByaXZhdGUgYmVhY2gsIHRoaXMgZXhxdWlzaXRlIHByb3BlcnR5IG9mZmVycyBicmVhdGh0YWtpbmcgb2NlYW4gdmlld3MgZnJvbSBldmVyeSBhbmdsZS5cIixcbiAgICAgICAgc2hvcnRfZGVzY3JpcHRpb246IFwiU3R1bm5pbmcgYmVhY2hmcm9udCB2aWxsYSB3aXRoIHByaXZhdGUgcG9vbCwgZGlyZWN0IGJlYWNoIGFjY2VzcywgYW5kIGJyZWF0aHRha2luZyBvY2VhbiB2aWV3cy5cIixcbiAgICAgICAgbG9jYXRpb246IFwiTWFsaWJ1LCBDYWxpZm9ybmlhXCIsXG4gICAgICAgIHByaWNlOiAxMjAwLjAwLFxuICAgICAgICBiZWRyb29tczogNSxcbiAgICAgICAgYmF0aHJvb21zOiA2LFxuICAgICAgICBtYXhfZ3Vlc3RzOiAxMixcbiAgICAgICAgaW1hZ2VzOiBbXG4gICAgICAgICAgXCIvaW1hZ2VzL3ZpbGxhLWV4dGVyaW9yLmpwZ1wiLFxuICAgICAgICAgIFwiL2ltYWdlcy92aWxsYS1pbnRlcmlvci0xLmpwZ1wiLFxuICAgICAgICAgIFwiL2ltYWdlcy92aWxsYS1pbnRlcmlvci0yLmpwZ1wiLFxuICAgICAgICAgIFwiL2ltYWdlcy92aWxsYS1iZWRyb29tLmpwZ1wiLFxuICAgICAgICAgIFwiL2ltYWdlcy92aWxsYS1iYXRocm9vbS5qcGdcIixcbiAgICAgICAgICBcIi9pbWFnZXMvdmlsbGEtcG9vbC5qcGdcIixcbiAgICAgICAgICBcIi9pbWFnZXMvdmlsbGEtYmVhY2guanBnXCIsXG4gICAgICAgICAgXCIvaW1hZ2VzL3ZpbGxhLWRpbmluZy5qcGdcIlxuICAgICAgICBdLFxuICAgICAgICBhbWVuaXRpZXM6IFtcbiAgICAgICAgICBcIlByaXZhdGUgUG9vbFwiLFxuICAgICAgICAgIFwiRGlyZWN0IEJlYWNoIEFjY2Vzc1wiLFxuICAgICAgICAgIFwiT2NlYW4gVmlld1wiLFxuICAgICAgICAgIFwiRnVsbHkgRXF1aXBwZWQgS2l0Y2hlblwiLFxuICAgICAgICAgIFwiQWlyIENvbmRpdGlvbmluZ1wiLFxuICAgICAgICAgIFwiRnJlZSBXaUZpXCIsXG4gICAgICAgICAgXCJTbWFydCBUVlwiLFxuICAgICAgICAgIFwiT3V0ZG9vciBEaW5pbmcgQXJlYVwiLFxuICAgICAgICAgIFwiQkJRIEdyaWxsXCIsXG4gICAgICAgICAgXCJQYXJraW5nXCIsXG4gICAgICAgICAgXCJHeW1cIixcbiAgICAgICAgICBcIkhvbWUgVGhlYXRlclwiLFxuICAgICAgICAgIFwiTGF1bmRyeSBGYWNpbGl0aWVzXCIsXG4gICAgICAgICAgXCIyNC83IFNlY3VyaXR5XCIsXG4gICAgICAgICAgXCJDb25jaWVyZ2UgU2VydmljZVwiXG4gICAgICAgIF0sXG4gICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfVxuICAgIF07XG4gICAgXG4gICAgbW9ja0Jvb2tpbmdzID0gW107XG4gICAgXG4gICAgY29uc29sZS5sb2coJ01vY2sgZGF0YSBsb2FkZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBtb2NrIGRhdGE6JywgZXJyb3IpO1xuICB9XG59O1xuXG4vLyBMb2FkIG1vY2sgZGF0YSBvbiBpbml0aWFsaXphdGlvbiBpZiBuZWVkZWRcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAoIXN1cGFiYXNlVXJsIHx8ICFzdXBhYmFzZUFub25LZXkpKSB7XG4gIGxvYWRNb2NrRGF0YSgpO1xufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gdGVzdCBTdXBhYmFzZSBjb25uZWN0aW9uXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdGVzdFN1cGFiYXNlQ29ubmVjdGlvbigpIHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygnVGVzdGluZyBTdXBhYmFzZSBjb25uZWN0aW9uLi4uJyk7XG4gICAgY29uc3QgY2xpZW50ID0gZ2V0U3VwYWJhc2VDbGllbnQoKTtcbiAgICBcbiAgICAvLyBUcnkgYSBzaW1wbGUgcXVlcnkgdG8gY2hlY2sgY29ubmVjdGlvblxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IGNsaWVudFxuICAgICAgLmZyb20oJ3ZpbGxhcycpXG4gICAgICAuc2VsZWN0KCdpZCwgbmFtZScpXG4gICAgICAubGltaXQoMSk7XG4gICAgICBcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1N1cGFiYXNlIGNvbm5lY3Rpb24gdGVzdCBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIHsgXG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLCBcbiAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgIGRldGFpbHM6IGVycm9yLFxuICAgICAgICBjbGllbnRUeXBlOiBjbGllbnQgPT09IHN1cGFiYXNlQ2xpZW50ID8gJ2Fub24nIDogY2xpZW50ID09PSBzdXBhYmFzZUFkbWluQ2xpZW50ID8gJ2FkbWluJyA6ICdtb2NrJ1xuICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coJ1N1cGFiYXNlIGNvbm5lY3Rpb24gc3VjY2Vzc2Z1bDonLCBkYXRhKTtcbiAgICByZXR1cm4geyBcbiAgICAgIHN1Y2Nlc3M6IHRydWUsIFxuICAgICAgZGF0YSwgXG4gICAgICBjbGllbnRUeXBlOiBjbGllbnQgPT09IHN1cGFiYXNlQ2xpZW50ID8gJ2Fub24nIDogY2xpZW50ID09PSBzdXBhYmFzZUFkbWluQ2xpZW50ID8gJ2FkbWluJyA6ICdtb2NrJ1xuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgdGVzdGluZyBTdXBhYmFzZSBjb25uZWN0aW9uOicsIGVycm9yKTtcbiAgICByZXR1cm4geyBcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLCBcbiAgICAgIGVycm9yOiBTdHJpbmcoZXJyb3IpLFxuICAgICAgY2xpZW50VHlwZTogJ3Vua25vd24nXG4gICAgfTtcbiAgfVxufSAiXSwibmFtZXMiOlsiY3JlYXRlQ2xpZW50IiwibW9ja1ZpbGxhcyIsIm1vY2tCb29raW5ncyIsInN1cGFiYXNlVXJsIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCIsInN1cGFiYXNlQW5vbktleSIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZIiwic3VwYWJhc2VTZXJ2aWNlS2V5IiwiU1VQQUJBU0VfU0VSVklDRV9LRVkiLCJzdXBhYmFzZUNsaWVudCIsInN1cGFiYXNlQWRtaW5DbGllbnQiLCJjb25zb2xlIiwibG9nIiwidXJsRXhpc3RzIiwiYW5vbktleUV4aXN0cyIsInNlcnZpY2VLZXlFeGlzdHMiLCJlcnJvciIsImF1dGgiLCJhdXRvUmVmcmVzaFRva2VuIiwicGVyc2lzdFNlc3Npb24iLCJjcmVhdGVNb2NrQ2xpZW50Iiwid2FybiIsImZyb20iLCJ0YWJsZSIsInNlbGVjdCIsImNvbHVtbnMiLCJtb2NrUmVzdWx0IiwiZGF0YSIsImVxIiwiY29sdW1uIiwidmFsdWUiLCJmaWx0ZXJlZCIsImZpbHRlciIsIml0ZW0iLCJsaW1pdCIsIm4iLCJzbGljZSIsInNpbmdsZSIsImxlbmd0aCIsIm1lc3NhZ2UiLCJsaW1pdGVkRGF0YSIsImluc2VydCIsIm5ld0l0ZW0iLCJpZCIsIkRhdGUiLCJub3ciLCJjcmVhdGVkX2F0IiwidG9JU09TdHJpbmciLCJwdXNoIiwidXBkYXRlIiwiaW5kZXgiLCJmaW5kSW5kZXgiLCJtYXRjaCIsImRlbGV0ZSIsImRlbGV0ZWQiLCJzcGxpY2UiLCJnZXRTdXBhYmFzZUNsaWVudCIsImFkbWluIiwic3VwYWJhc2UiLCJnZXRWaWxsYUJ5SWQiLCJjbGllbnQiLCJjcmVhdGVCb29raW5nIiwiYm9va2luZ0RhdGEiLCJ2aWxsYUlkIiwidmlsbGFfaWQiLCJpc1ZhbGlkVVVJRCIsInZpbGxhcyIsIkVycm9yIiwibmV3VmlsbGEiLCJ2aWxsYUVycm9yIiwibmFtZSIsImRlc2NyaXB0aW9uIiwic2hvcnRfZGVzY3JpcHRpb24iLCJsb2NhdGlvbiIsInByaWNlIiwidG90YWxfYW1vdW50IiwiYmVkcm9vbXMiLCJiYXRocm9vbXMiLCJtYXhfZ3Vlc3RzIiwiZ3Vlc3RzIiwiaW1hZ2VzIiwiYW1lbml0aWVzIiwiZXJyIiwidHJhbnNhY3Rpb24iLCJ0cmFuc2FjdGlvbkVycm9yIiwicGF5bWVudF9pZCIsImFtb3VudCIsInN0YXR1cyIsInBheW1lbnRfbWV0aG9kIiwicGF5bWVudF9kZXRhaWxzIiwic291cmNlIiwiaGFzUGF5bWVudElkQ29sdW1uIiwidGVzdEluc2VydCIsImNoZWNrX2luIiwiY2hlY2tfb3V0IiwiZmlyc3RfbmFtZSIsImxhc3RfbmFtZSIsImVtYWlsIiwicGhvbmUiLCJ0ZXN0RXJyb3IiLCJpbmNsdWRlcyIsImJvb2tpbmdJbnNlcnQiLCJzcGVjaWFsX3JlcXVlc3RzIiwiYm9va2luZyIsImJvb2tpbmdFcnJvciIsInJldHJ5Qm9va2luZyIsInJldHJ5RXJyb3IiLCJ1cGRhdGVFcnJvciIsImJvb2tpbmdfaWQiLCJzdHIiLCJ1dWlkUmVnZXgiLCJ0ZXN0IiwiY2hlY2tWaWxsYUF2YWlsYWJpbGl0eSIsImNoZWNrSW4iLCJjaGVja091dCIsInF1ZXJ5IiwicmVxdWVzdFN0YXJ0IiwiZ2V0VGltZSIsInJlcXVlc3RFbmQiLCJoYXNDb25mbGljdCIsInNvbWUiLCJib29raW5nU3RhcnQiLCJib29raW5nRW5kIiwibG9hZE1vY2tEYXRhIiwidGVzdFN1cGFiYXNlQ29ubmVjdGlvbiIsInN1Y2Nlc3MiLCJkZXRhaWxzIiwiY2xpZW50VHlwZSIsIlN0cmluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./utils/supabase.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fbooking&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Fbooking.ts&middlewareConfigBase64=e30%3D!")));
module.exports = __webpack_exports__;

})();